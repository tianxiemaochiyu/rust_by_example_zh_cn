(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{665:function(n,e,t){"use strict";t.r(e);var s=t(4),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"别名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#别名"}},[n._v("#")]),n._v(" 别名")]),n._v(" "),t("p",[n._v("可以用 "),t("code",[n._v("type")]),n._v(" 语句给已有的类型取个新的名字。类型的名字必须遵循驼峰命名法（像是\n"),t("code",[n._v("CamelCase")]),n._v(" 这样），否则编译器将给出错误。原生类型是例外，比如：\n"),t("code",[n._v("usize")]),n._v("、"),t("code",[n._v("f32")]),n._v("，等等。")]),n._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// `NanoSecond` 是 `u64` 的新名字。\ntype NanoSecond = u64;\ntype Inch = u64;\n\n// 通过这个属性屏蔽警告。\n#[allow(non_camel_case_types)]\ntype u64_t = u64;\n// 试一试 ^ 移除上面那个属性\n\nfn main() {\n    // `NanoSecond` = `Inch` = `u64_t` = `u64`.\n    let nanoseconds: NanoSecond = 5 as u64_t;\n    let inches: Inch = 2 as u64_t;\n\n    // 注意类型别名*并不能*提供额外的类型安全，因为别名*并不是*新的类型。\n    println!("{} nanoseconds + {} inches = {} unit?",\n             nanoseconds,\n             inches,\n             nanoseconds + inches);\n}\n')])])]),t("p",[n._v("别名的主要用途是避免写出冗长的模板化代码（boilerplate code）。如 "),t("code",[n._v("IoResult<T>")]),n._v("\n是 "),t("code",[n._v("Result<T, IoError>")]),n._v(" 类型的别名。")]),n._v(" "),t("h3",{attrs:{id:"see-also"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#see-also"}},[n._v("#")]),n._v(" See also:")]),n._v(" "),t("p",[t("RouterLink",{attrs:{to:"/attribute.html"}},[n._v("Attributes")])],1)])}),[],!1,null,null,null);e.default=a.exports}}]);