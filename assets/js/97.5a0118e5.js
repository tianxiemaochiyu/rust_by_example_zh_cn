(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{574:function(t,n,e){"use strict";e.r(n);var o=e(4),r=Object(o.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"测试实例：单位说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试实例：单位说明"}},[t._v("#")]),t._v(" 测试实例：单位说明")]),t._v(" "),e("p",[t._v("通过实现一个带虚类型参数的 "),e("code",[t._v("Add")]),t._v(" trait 可以实现单位检查。这种 "),e("code",[t._v("Add")]),t._v(" trait 的\n代码如下：")]),t._v(" "),e("div",{staticClass:"language-rust,ignore extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 这个 `trait` 会要求 `Self + RHS = Output`。`<RHS = Self>` 表示 RHS 的默认值\n// 为 Self 类型，也就是如果没有在实现中另行指定，RHS 就取 Self 类型。\npub trait Add<RHS = Self> {\n    type Output;\n\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n\n// `Output` 必须是 `T<U>` 类型，所以是 `T<U> + T<U> = T<U>`。\nimpl<U> Add for T<U> {\n    type Output = T<U>;\n    ...\n}\n")])])]),e("p",[t._v("完整实现：")]),t._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('use std::ops::Add;\nuse std::marker::PhantomData;\n\n/// 创建空枚举类型来表示单位。\n#[derive(Debug, Clone, Copy)]\nenum Inch {}\n#[derive(Debug, Clone, Copy)]\nenum Mm {}\n\n/// `Length` 是一个带有虚类型参数 `Unit` 的类型，\n/// 而且对于表示长度的类型（即 `f64`）而言，`Length` 不是泛型的。\n///\n/// `f64` 已经实现了 `Clone` 和 `Copy` trait.\n#[derive(Debug, Clone, Copy)]\nstruct Length<Unit>(f64, PhantomData<Unit>);\n\n/// `Add` trait 定义了 `+` 运算符的行为。\nimpl<Unit> Add for Length<Unit> {\n     type Output = Length<Unit>;\n\n    // add() 返回一个含有和的新的 `Length` 结构体。\n    fn add(self, rhs: Length<Unit>) -> Length<Unit> {\n        // `+` 调用了针对 `f64` 类型的 `Add` 实现。\n        Length(self.0 + rhs.0, PhantomData)\n    }\n}\n\nfn main() {\n    // 指定 `one_foot` 拥有虚类型参数 `Inch`。\n    let one_foot:  Length<Inch> = Length(12.0, PhantomData);\n    // `one_meter` 拥有虚类型参数 `Mm`。\n    let one_meter: Length<Mm>   = Length(1000.0, PhantomData);\n\n    // `+` 调用了我们对 `Length<Unit>` 实现的 `add()` 方法。\n    //\n    // 由于 `Length` 了实现了 `Copy`，`add()` 不会消耗 `one_foot`\n    // 和 `one_meter`，而是复制它们作为 `self` 和 `rhs`。\n    let two_feet = one_foot + one_foot;\n    let two_meters = one_meter + one_meter;\n\n    // 加法正常执行。\n    println!("one foot + one_foot = {:?} in", two_feet.0);\n    println!("one meter + one_meter = {:?} mm", two_meters.0);\n\n    // 无意义的运算当然会失败：\n    // 编译期错误：类型不匹配。\n    //let one_feter = one_foot + one_meter;\n}\n\n')])])]),e("h3",{attrs:{id:"参见："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/scope/borrow.html"}},[t._v("Borrowing ("),e("code",[t._v("&")]),t._v(")")]),t._v(", "),e("RouterLink",{attrs:{to:"/generics/bounds.html"}},[t._v("Bounds ("),e("code",[t._v("X: Y")]),t._v(")")]),t._v(", "),e("RouterLink",{attrs:{to:"/custom_types/enum.html"}},[t._v("enum")]),t._v(", "),e("RouterLink",{attrs:{to:"/fn/methods.html"}},[t._v("impl & self")]),t._v(",\n"),e("RouterLink",{attrs:{to:"/trait/ops.html"}},[t._v("Overloading")]),t._v(", "),e("RouterLink",{attrs:{to:"/scope/borrow/ref.html"}},[t._v("ref")]),t._v(", "),e("RouterLink",{attrs:{to:"/trait.html"}},[t._v("Traits ("),e("code",[t._v("X for Y")]),t._v(")")]),t._v(", 和 "),e("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[t._v("TupleStructs")]),t._v(".")],1)])}),[],!1,null,null,null);n.default=r.exports}}]);