(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{535:function(t,n,a){"use strict";a.r(n);var e=a(4),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"if-let"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if-let"}},[t._v("#")]),t._v(" if let")]),t._v(" "),a("p",[t._v("在一些场合下，用 "),a("code",[t._v("match")]),t._v(" 匹配枚举类型并不优雅。比如：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将 `optional` 定为 `Option<i32>` 类型")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" optional "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Some")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),t._v(" optional "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Some")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is a really long string and `{:?}`"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ^ 行首需要 2 层缩进。这里从 optional 中解构出 `i`。")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 译注：正确的缩进是好的，但并不是 “不缩进就不能运行” 这个意思。")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    _ "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ^ 必须有，因为 `match` 需要覆盖全部情况。不觉得这行很多余吗？")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[a("code",[t._v("if let")]),t._v(" 在这样的场合要简洁得多，并且允许指明数种失败情形下的选项：")]),t._v(" "),a("div",{staticClass:"language-rust,editable extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    // 全部都是 `Option<i32>` 类型\n    let number = Some(7);\n    let letter: Option<i32> = None;\n    let emoticon: Option<i32> = None;\n\n    // `if let` 结构读作：若 `let` 将 `number` 解构成 `Some(i)`，则执行\n    // 语句块（`{}`）\n    if let Some(i) = number {\n        println!("Matched {:?}!", i);\n    }\n\n    // 如果要指明失败情形，就使用 else：\n    if let Some(i) = letter {\n        println!("Matched {:?}!", i);\n    } else {\n        // 解构失败。切换到失败情形。\n        println!("Didn\'t match a number. Let\'s go with a letter!");\n    };\n\n    // 提供另一种失败情况下的条件。\n    let i_like_letters = false;\n\n    if let Some(i) = emoticon {\n        println!("Matched {:?}!", i);\n    // 解构失败。使用 `else if` 来判断是否满足上面提供的条件。\n    } else if i_like_letters {\n        println!("Didn\'t match a number. Let\'s go with a letter!");\n    } else {\n        // 条件的值为 false。于是以下是默认的分支：\n        println!("I don\'t like letters. Let\'s go with an emoticon :)!");\n    };\n}\n')])])]),a("p",[t._v("同样，可以用 "),a("code",[t._v("if let")]),t._v(" 匹配任何枚举值：")]),t._v(" "),a("div",{staticClass:"language-rust,editable extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// 以这个 enum 类型为例\nenum Foo {\n    Bar,\n    Baz,\n    Qux(u32)\n}\n\nfn main() {\n    // 创建变量\n    let a = Foo::Bar;\n    let b = Foo::Baz;\n    let c = Foo::Qux(100);\n    \n    // 变量 a 匹配到了 Foo::Bar\n    if let Foo::Bar = a {\n        println!("a is foobar");\n    }\n    \n    // 变量 b 没有匹配到 Foo::Bar，因此什么也不会打印。\n    if let Foo::Bar = b {\n        println!("b is foobar");\n    }\n    \n    // 变量 c 匹配到了 Foo::Qux，它带有一个值，就和上面例子中的 Some() 类似。\n    if let Foo::Qux(value) = c {\n        println!("c is {}", value);\n    }\n}\n')])])]),a("p",[t._v("另一个好处是："),a("code",[t._v("if let")]),t._v(" 允许匹配枚举非参数化的变量，即枚举未注明 "),a("code",[t._v("#[derive(PartialEq)]")]),t._v("，我们也没有为其实现 "),a("code",[t._v("PartialEq")]),t._v("。在这种情况下，通常 "),a("code",[t._v("if Foo::Bar==a")]),t._v(" 会出错，因为此类枚举的实例不具有可比性。但是，"),a("code",[t._v("if let")]),t._v(" 是可行的。")]),t._v(" "),a("p",[t._v("你想挑战一下吗？使用 "),a("code",[t._v("if let")]),t._v("修复以下示例：")]),t._v(" "),a("div",{staticClass:"language-rust,editable,ignore,mdbook-runnable extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// 该枚举故意未注明 `#[derive(PartialEq)]`，\n// 并且也没为其实现 `PartialEq`。这就是为什么下面比较 `Foo::Bar==a` 会失败的原因。\nenum Foo {Bar}\n\nfn main() {\n    let a = Foo::Bar;\n\n    // 变量匹配 Foo::Bar\n    if Foo::Bar == a {\n    // ^-- 这就是编译时发现的错误。使用 `if let` 来替换它。\n        println!("a is foobar");\n    }\n}\n')])])]),a("h3",{attrs:{id:"参见："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/custom_types/enum.html"}},[a("code",[t._v("枚举")])]),t._v("，"),a("RouterLink",{attrs:{to:"/std/option.html"}},[a("code",[t._v("Option")])]),t._v("，和相关的 "),a("a",{attrs:{href:"https://github.com/rust-lang/rfcs/pull/160",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC"),a("OutboundLink")],1)],1)])}),[],!1,null,null,null);n.default=s.exports}}]);