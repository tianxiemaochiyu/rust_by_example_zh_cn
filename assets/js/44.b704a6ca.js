(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{524:function(r,e,n){"use strict";n.r(e);var t=n(4),o=Object(t.a)({},(function(){var r=this,e=r.$createElement,n=r._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[n("h1",{attrs:{id:"包裹错误"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#包裹错误"}},[r._v("#")]),r._v(" 包裹错误")]),r._v(" "),n("p",[r._v("把错误装箱这种做法也可以改成把它包裹到你自己的错误类型中。")]),r._v(" "),n("div",{staticClass:"language-rust,editable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[r._v('use std::error;\nuse std::num::ParseIntError;\nuse std::fmt;\n\ntype Result<T> = std::result::Result<T, DoubleError>;\n\n#[derive(Debug)]\nenum DoubleError {\n    EmptyVec,\n    // 在这个错误类型中，我们采用 `parse` 的错误类型中 `Err` 部分的实现。\n    // 若想提供更多信息，则该类型中还需要加入更多数据。\n    Parse(ParseIntError),\n}\n\nimpl fmt::Display for DoubleError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            DoubleError::EmptyVec =>\n                write!(f, "please use a vector with at least one element"),\n            // 这是一个封装（wrapper），它采用内部各类型对 `fmt` 的实现。\n            DoubleError::Parse(ref e) => e.fmt(f),\n        }\n    }\n}\n\nimpl error::Error for DoubleError {\n    fn description(&self) -> &str {\n        match *self {\n            DoubleError::EmptyVec => "empty vectors not allowed",\n            // 这已经实现了 `Error`，所以采用它自己的实现。\n            DoubleError::Parse(ref e) => e.description(),\n        }\n    }\n\n    fn cause(&self) -> Option<&error::Error> {\n        match *self {\n            DoubleError::EmptyVec => None,\n            // 原因采取内部对错误类型的实现。它隐式地转换成了 trait 对象 `&error:Error`。\n            // 这可以工作，因为内部的类型已经实现了 `Error` trait。\n            DoubleError::Parse(ref e) => Some(e),\n        }\n    }\n}\n\n// 实现从 `ParseIntError` 到 `DoubleError` 的转换。\n// 在使用 `?` 时，或者一个 `ParseIntError` 需要转换成 `DoubleError` 时，它会被自动调用。\nimpl From<ParseIntError> for DoubleError {\n    fn from(err: ParseIntError) -> DoubleError {\n        DoubleError::Parse(err)\n    }\n}\n\nfn double_first(vec: Vec<&str>) -> Result<i32> {\n    let first = vec.first().ok_or(DoubleError::EmptyVec)?;\n    let parsed = first.parse::<i32>()?;\n\n    Ok(2 * parsed)\n}\n\nfn print(result: Result<i32>) {\n    match result {\n        Ok(n)  => println!("The first doubled is {}", n),\n        Err(e) => println!("Error: {}", e),\n    }\n}\n\nfn main() {\n    let numbers = vec!["42", "93", "18"];\n    let empty = vec![];\n    let strings = vec!["tofu", "93", "18"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n')])])]),n("p",[r._v("这种做法会在错误处理中增加一些模板化的代码，而且也不是所有的应用都需要这样做。一些\n库可以帮你处理模板化代码的问题。")]),r._v(" "),n("h3",{attrs:{id:"see-also"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#see-also"}},[r._v("#")]),r._v(" See also:")]),r._v(" "),n("p",[n("a",{attrs:{href:"https://doc.rust-lang.org/std/convert/trait.From.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[r._v("From::from")]),n("OutboundLink")],1),r._v(" and "),n("RouterLink",{attrs:{to:"/custom_types/enum.html"}},[n("code",[r._v("枚举类型")])])],1)])}),[],!1,null,null,null);e.default=o.exports}}]);