(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{601:function(n,t,i){"use strict";i.r(t);var e=i(4),_=Object(e.a)({},(function(){var n=this,t=n.$createElement,i=n._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h1",{attrs:{id:"可见性"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#可见性"}},[n._v("#")]),n._v(" 可见性")]),n._v(" "),i("p",[n._v("默认情况下，模块中的项拥有私有的可见性（private visibility），不过可以加上\n"),i("code",[n._v("pub")]),n._v(" 修饰语来重载这一行为。模块中只有公有的（public）项可以从模块外的作用域\n访问。")]),n._v(" "),i("div",{staticClass:"language-rust,editable extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('// 一个名为 `my_mod` 的模块\nmod my_mod {\n    // 模块中的项默认具有私有的可见性\n    fn private_function() {\n        println!("called `my_mod::private_function()`");\n    }\n\n    // 使用 `pub` 修饰语来改变默认可见性。\n    pub fn function() {\n        println!("called `my_mod::function()`");\n    }\n\n    // 在同一模块中，项可以访问其它项，即使它是私有的。\n    pub fn indirect_access() {\n        print!("called `my_mod::indirect_access()`, that\\n> ");\n        private_function();\n    }\n\n    // 模块也可以嵌套\n    pub mod nested {\n        pub fn function() {\n            println!("called `my_mod::nested::function()`");\n        }\n\n        #[allow(dead_code)]\n        fn private_function() {\n            println!("called `my_mod::nested::private_function()`");\n        }\n\n        // 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。\n        // `path` 必须是父模块（parent module）或祖先模块（ancestor module）\n        pub(in my_mod) fn public_function_in_my_mod() {\n            print!("called `my_mod::nested::public_function_in_my_mod()`, that\\n > ");\n            public_function_in_nested()\n        }\n\n        // 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。\n        pub(self) fn public_function_in_nested() {\n            println!("called `my_mod::nested::public_function_in_nested");\n        }\n\n        // 使用 `pub(super)` 语法定义的函数只在父模块中可见。\n        pub(super) fn public_function_in_super_mod() {\n            println!("called my_mod::nested::public_function_in_super_mod");\n        }\n    }\n\n    pub fn call_public_function_in_my_mod() {\n        print!("called `my_mod::call_public_funcion_in_my_mod()`, that\\n> ");\n        nested::public_function_in_my_mod();\n        print!("> ");\n        nested::public_function_in_super_mod();\n    }\n\n    // `pub(crate)` 使得函数只在当前 crate 中可见\n    pub(crate) fn public_function_in_crate() {\n        println!("called `my_mod::public_function_in_crate()");\n    }\n\n    // 嵌套模块的可见性遵循相同的规则\n    mod private_nested {\n        #[allow(dead_code)]\n        pub fn function() {\n            println!("called `my_mod::private_nested::function()`");\n        }\n    }\n}\n\nfn function() {\n    println!("called `function()`");\n}\n\nfn main() {\n    // 模块机制消除了相同名字的项之间的歧义。\n    function();\n    my_mod::function();\n\n    // 公有项，包括嵌套模块内的，都可以在父模块外部访问。\n    my_mod::indirect_access();\n    my_mod::nested::function();\n    my_mod::call_public_function_in_my_mod();\n\n    // pub(crate) 项可以在同一个 crate 中的任何地方访问\n    my_mod::public_function_in_crate();\n\n    // pub(in path) 项只能在指定的模块中访问\n    // 报错！函数 `public_function_in_my_mod` 是私有的\n    //my_mod::nested::public_function_in_my_mod();\n    // 试一试 ^ 取消该行的注释\n\n    // 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的\n\n    // 报错！`private_function` 是私有的\n    //my_mod::private_function();\n    // 试一试 ^ 取消此行注释\n\n    // 报错！`private_function` 是私有的\n    //my_mod::nested::private_function();\n    // 试一试 ^ 取消此行的注释\n\n    // Error! `private_nested` is a private module\n    //my_mod::private_nested::function();\n    // 试一试 ^ 取消此行的注释\n}\n')])])])])}),[],!1,null,null,null);t.default=_.exports}}]);