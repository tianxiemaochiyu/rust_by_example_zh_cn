(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{527:function(n,r,t){"use strict";t.r(r);var e=t(4),s=Object(e.a)({},(function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"提前返回"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提前返回"}},[n._v("#")]),n._v(" 提前返回")]),n._v(" "),t("p",[n._v("在上一个例子中，我们显式地使用组合算子处理了错误。另一种处理错误的方式是使用\n"),t("code",[n._v("match")]),n._v(" 语句和"),t("strong",[n._v("提前返回")]),n._v("（early return）的结合。")]),n._v(" "),t("p",[n._v("这也就是说，如果发生错误，我们可以停止函数的执行然后返回错误。对有些人来说，这样\n的代码更好写，更易读。这次我们使用提前返回改写之前的例子：")]),n._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('use std::num::ParseIntError;\n\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\n    let first_number = match first_number_str.parse::<i32>() {\n        Ok(first_number)  => first_number,\n        Err(e) => return Err(e),\n    };\n\n    let second_number = match second_number_str.parse::<i32>() {\n        Ok(second_number)  => second_number,\n        Err(e) => return Err(e),\n    };\n\n    Ok(first_number * second_number)\n}\n\nfn print(result: Result<i32, ParseIntError>) {\n    match result {\n        Ok(n)  => println!("n is {}", n),\n        Err(e) => println!("Error: {}", e),\n    }\n}\n\nfn main() {\n    print(multiply("10", "2"));\n    print(multiply("t", "2"));\n}\n')])])]),t("p",[n._v("到此为止，我们已经学会了如何使用组合算子和提前返回显式地处理错误。我们一般是\n想要避免 panic 的，但显式地处理所有错误确实显得过于繁琐。")]),n._v(" "),t("p",[n._v("在下一部分，我们将看到，当只是需要 "),t("code",[n._v("unwrap")]),n._v(" 并且不产生 "),t("code",[n._v("panic")]),n._v(" 时，可以使用\n"),t("code",[n._v("?")]),n._v(" 来达到同样的效果。")])])}),[],!1,null,null,null);r.default=s.exports}}]);