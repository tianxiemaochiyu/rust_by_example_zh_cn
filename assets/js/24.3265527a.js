(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{503:function(t,r,n){"use strict";n.r(r);var e=n(4),a=Object(e.a)({},(function(){var t=this,r=t.$createElement,n=t._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"from-和-into"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#from-和-into"}},[t._v("#")]),t._v(" "),n("code",[t._v("From")]),t._v(" 和 "),n("code",[t._v("Into")])]),t._v(" "),n("p",[n("a",{attrs:{href:"https://doc.rust-lang.org/std/convert/trait.From.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("From")]),n("OutboundLink")],1),t._v(" 和 "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/convert/trait.Into.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("Into")]),n("OutboundLink")],1),t._v(" 两个 trait 是内在地联系着的，事实上这是它们的实现的重要\n部分：如果能把类型 A 转换成类型 B，那么很容易相信我们也能把类型 B 转换成类型\nA。")]),t._v(" "),n("h2",{attrs:{id:"from"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#from"}},[t._v("#")]),t._v(" "),n("code",[t._v("From")])]),t._v(" "),n("p",[n("a",{attrs:{href:"https://doc.rust-lang.org/std/convert/trait.From.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("From")]),n("OutboundLink")],1),t._v(" trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种\n类型转换的简单机制。在标准库中有无数 "),n("code",[t._v("From")]),t._v(" 的实现，规定了原生类型及其他常见类\n型的转换功能。")]),t._v(" "),n("p",[t._v("比如，可以很容易地把 "),n("code",[t._v("str")]),t._v(" 转换成 "),n("code",[t._v("String")]),t._v("：")]),t._v(" "),n("div",{staticClass:"language-rust extra-class"},[n("pre",{pre:!0,attrs:{class:"language-rust"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" my_str "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" my_string "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("from")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("my_str"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("p",[t._v("也可以为我们自己的类型定义转换机制：")]),t._v(" "),n("div",{staticClass:"language-rust,editable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('use std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\n\nfn main() {\n    let num = Number::from(30);\n    println!("My number is {:?}", num);\n}\n')])])]),n("h2",{attrs:{id:"into"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#into"}},[t._v("#")]),t._v(" "),n("code",[t._v("Into")])]),t._v(" "),n("p",[n("a",{attrs:{href:"https://doc.rust-lang.org/std/convert/trait.Into.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("Into")]),n("OutboundLink")],1),t._v(" trait 就是把 "),n("code",[t._v("From")]),t._v(" trait 倒过来而已。也就是说，如果你为你的类型实现了\n"),n("code",[t._v("From")]),t._v("，那么同时你也就免费获得了 "),n("code",[t._v("Into")]),t._v("。")]),t._v(" "),n("p",[t._v("使用 "),n("code",[t._v("Into")]),t._v(" trait 通常要求指明要转换到的类型，因为编译器大多数时候不能推断它。不\n过考虑到我们免费获得了 "),n("code",[t._v("Into")]),t._v("，这点代价不值一提。")]),t._v(" "),n("div",{staticClass:"language-rust,editable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('use std::convert::From;\n\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\n\nfn main() {\n    let int = 5;\n    // 试试删除类型说明\n    let num: Number = int.into();\n    println!("My number is {:?}", num);\n}\n')])])])])}),[],!1,null,null,null);r.default=a.exports}}]);