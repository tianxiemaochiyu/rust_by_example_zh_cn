(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{669:function(t,e,s){"use strict";s.r(e);var a=s(4),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"不安全操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不安全操作"}},[t._v("#")]),t._v(" 不安全操作")]),t._v(" "),s("p",[t._v("在本章一开始，我们借用"),s("a",{attrs:{href:"unsafe"}},[t._v("官方文档")]),t._v("的一句话，“在整个代码库（code base，指\n构建一个软件系统所使用的全部代码）中，要尽可能减少不安全代码的量”。记住这句\n话，接着我们进入学习！在 Rust 中，不安全代码块用于避开编译器的保护策略；具体\n地说，不安全代码块主要用于四件事情：")]),t._v(" "),s("ul",[s("li",[t._v("解引用裸指针")]),t._v(" "),s("li",[t._v("通过 FFI 调用函数（这已经在"),s("RouterLink",{attrs:{to:"/std_misc/ffi.html"}},[t._v("之前的章节")]),t._v("介绍过了）")],1),t._v(" "),s("li",[t._v("调用不安全的函数")]),t._v(" "),s("li",[t._v("内联汇编（inline assembly）")])]),t._v(" "),s("h3",{attrs:{id:"原始指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原始指针"}},[t._v("#")]),t._v(" 原始指针")]),t._v(" "),s("p",[t._v("原始指针（raw pointer，裸指针）"),s("code",[t._v("*")]),t._v(" 和引用 "),s("code",[t._v("&T")]),t._v(" 有类似的功能，但引用总是安全\n的，因为借用检查器保证了它指向一个有效的数据。解引用一个裸指针只能通过不安全\n代码块执行。")]),t._v(" "),s("div",{staticClass:"language-rust,editable extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("fn main() {\n    let raw_p: *const u32 = &10;\n\n    unsafe {\n        assert!(*raw_p == 10);\n    }\n}\n")])])]),s("h3",{attrs:{id:"调用不安全函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用不安全函数"}},[t._v("#")]),t._v(" 调用不安全函数")]),t._v(" "),s("p",[t._v("一些函数可以声明为不安全的（"),s("code",[t._v("unsafe")]),t._v("），这意味着在使用它时保证正确性不再是编译器\n的责任，而是程序员的。一个例子就是 "),s("a",{attrs:{href:"https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("std::slice::from_raw_parts")]),s("OutboundLink")],1),t._v("，向它传入指向\n第一个元素的指针和长度参数，它会创建一个切片。")]),t._v(" "),s("div",{staticClass:"language-rust,editable extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("use std::slice;\n\nfn main() {\n    let some_vector = vec![1, 2, 3, 4];\n\n    let pointer = some_vector.as_ptr();\n    let length = some_vector.len();\n\n    unsafe {\n        let my_slice: &[u32] = slice::from_raw_parts(pointer, length);\n        \n        assert_eq!(some_vector.as_slice(), my_slice);\n    }\n}\n")])])]),s("p",[s("code",[t._v("slice::from_raw_parts")]),t._v(" 假设传入的指针指向有效的内存，且被指向的内存具有正确的\n数据类型，我们"),s("strong",[t._v("必须")]),t._v("满足这一假设，否则程序的行为是未定义的（undefined），于是\n我们就不能预测会发生些什么了。")])])}),[],!1,null,null,null);e.default=n.exports}}]);