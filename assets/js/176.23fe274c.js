(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{655:function(n,t,s){"use strict";s.r(t);var a=s(4),e=Object(a.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"文档测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文档测试"}},[n._v("#")]),n._v(" 文档测试")]),n._v(" "),s("p",[n._v("为 Rust 工程编写文档的主要方式是在源代码中写注释。文档注释使用 "),s("a",{attrs:{href:"https://daringfireball.net/projects/markdown/",target:"_blank",rel:"noopener noreferrer"}},[n._v("markdown"),s("OutboundLink")],1),n._v(" 语法\n书写，支持代码块。Rust 很注重正确性，这些注释中的代码块也会被编译并且用作测试。")]),n._v(" "),s("div",{staticClass:"language-rust,ignore extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('/// 第一行是对函数的简短描述。\n///\n/// 接下来数行是详细文档。代码块用三个反引号开启，Rust 会隐式地在其中添加\n/// `fn main()` 和 `extern crate <cratename>`。比如测试 `doccomments` crate：\n///\n/// ```\n/// let result = doccomments::add(2, 3);\n/// assert_eq!(result, 5);\n/// ```\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n/// 文档注释通常可能带有 "Examples"、"Panics" 和 "Failures" 这些部分。\n///\n/// 下面的函数将两数相除。\n///\n/// # Examples\n///\n/// ```\n/// let result = doccomments::div(10, 2);\n/// assert_eq!(result, 5);\n/// ```\n///\n/// # Panics\n///\n/// 如果第二个参数是 0，函数将会 panic。\n///\n/// ```rust,should_panic\n/// // panics on division by zero\n/// doccomments::div(10, 0);\n/// ```\npub fn div(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        panic!("Divide-by-zero error");\n    }\n\n    a / b\n}\n')])])]),s("p",[n._v("这些测试仍然可以通过 "),s("code",[n._v("cargo test")]),n._v(" 执行：")]),n._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[n._v("$ cargo "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[n._v("test")]),n._v("\nrunning "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" tests\n\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[n._v("test")]),n._v(" result: ok. "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" passed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" failed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" ignored"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" measured"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" filtered out\n\n   Doc-tests doccomments\n\nrunning "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("3")]),n._v(" tests\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[n._v("test")]),n._v(" src/lib.rs - "),s("span",{pre:!0,attrs:{class:"token function"}},[n._v("add")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("line "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("..")]),n._v(". ok\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[n._v("test")]),n._v(" src/lib.rs - div "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("line "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("21")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("..")]),n._v(". ok\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[n._v("test")]),n._v(" src/lib.rs - div "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("line "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("..")]),n._v(". ok\n\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[n._v("test")]),n._v(" result: ok. "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("3")]),n._v(" passed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" failed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" ignored"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" measured"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(";")]),n._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),n._v(" filtered out\n")])])]),s("h2",{attrs:{id:"文档测试的目的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文档测试的目的"}},[n._v("#")]),n._v(" 文档测试的目的")]),n._v(" "),s("p",[n._v("文档测试的主要目的是作为使用函数功能的例子，这是最重要的"),s("a",{attrs:{href:"https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark",target:"_blank",rel:"noopener noreferrer"}},[n._v("指导\n原则"),s("OutboundLink")],1),n._v("之一。文档测试应当可以作为完整的代码段被直接\n使用（很多用户会复制文档中的代码来用，所以例子要写得完善）。但使用 "),s("code",[n._v("?")]),n._v(" 符号会\n导致编译失败，因为 "),s("code",[n._v("main")]),n._v(" 函数会返回 "),s("code",[n._v("unit")]),n._v(" 类型。幸运的是，我们可以在文档中\n隐藏几行源代码：你可以写 "),s("code",[n._v("fn try_main() -> Result<(), ErrorType>")]),n._v(" 这样的\n函数，把它隐藏起来，然后在隐藏的 "),s("code",[n._v("main")]),n._v(" 中展开它。听起来很复杂？请看例子：")]),n._v(" "),s("div",{staticClass:"language-rust,ignore extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('/// 在文档测试中使用隐藏的 `try_main`。\n///\n/// ```\n/// # // 被隐藏的行以 `#` 开始，但它们仍然会被编译！\n/// # fn try_main() -> Result<(), String> { // 隐藏行包围了文档中显示的函数体\n/// let res = try::try_div(10, 2)?;\n/// # Ok(()) // 从 try_main 返回\n/// # }\n/// # fn main() { // 开始主函数，其中将展开 `try_main` 函数\n/// #    try_main().unwrap(); // 调用并展开 try_main，这样出错时测试会 panic\n/// # }\npub fn try_div(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        Err(String::from("Divide-by-zero"))\n    } else {\n        Ok(a / b)\n    }\n}\n')])])]),s("h2",{attrs:{id:"参见"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参见"}},[n._v("#")]),n._v(" 参见")]),n._v(" "),s("ul",[s("li",[n._v("关于文档风格的 "),s("a",{attrs:{href:"https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md",target:"_blank",rel:"noopener noreferrer"}},[n._v("RFC505"),s("OutboundLink")],1)]),n._v(" "),s("li",[s("a",{attrs:{href:"https://rust-lang-nursery.github.io/api-guidelines/documentation.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("API 指导原则"),s("OutboundLink")],1),n._v("中关于文档的原则")])])])}),[],!1,null,null,null);t.default=e.exports}}]);