(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{525:function(o,n,e){"use strict";e.r(n);var t=e(4),d=Object(t.a)({},(function(){var o=this,n=o.$createElement,e=o._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("h1",{attrs:{id:"组合算子：and-then"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组合算子：and-then"}},[o._v("#")]),o._v(" 组合算子："),e("code",[o._v("and_then")])]),o._v(" "),e("p",[e("code",[o._v("map()")]),o._v(" 以链式调用的方式来简化 "),e("code",[o._v("match")]),o._v(" 语句。然而，如果以返回类型是 "),e("code",[o._v("Option<T>")]),o._v("\n的函数作为 "),e("code",[o._v("map()")]),o._v(" 的参数，会导致出现嵌套形式 "),e("code",[o._v("Option<Option<T>>")]),o._v("。这样多层串联\n调用就会变得混乱。所以有必要引入 "),e("code",[o._v("and_then()")]),o._v("，在某些语言中它叫做 flatmap。")]),o._v(" "),e("p",[e("code",[o._v("and_then()")]),o._v(" 使用被 "),e("code",[o._v("Option")]),o._v(" 包裹的值来调用其输入函数并返回结果。 如果 "),e("code",[o._v("Option")]),o._v("\n是 "),e("code",[o._v("None")]),o._v("，那么它返回 "),e("code",[o._v("None")]),o._v("。")]),o._v(" "),e("p",[o._v("在下面例子中，"),e("code",[o._v("cookable_v2()")]),o._v(" 会产生一个 "),e("code",[o._v("Option<Food>")]),o._v("。如果在这里使用 "),e("code",[o._v("map()")]),o._v("\n而不是 "),e("code",[o._v("and_then()")]),o._v(" 将会得到 "),e("code",[o._v("Option<Option<Food>>")]),o._v("，这对 "),e("code",[o._v("eat()")]),o._v(" 来说是一个\n无效类型。")]),o._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[o._v('#![allow(dead_code)]\n\n#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }\n#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }\n\n// 我们没有制作寿司所需的原材料（ingredient）（有其他的原材料）。\nfn have_ingredients(food: Food) -> Option<Food> {\n    match food {\n        Food::Sushi => None,\n        _           => Some(food),\n    }\n}\n\n// 我们拥有全部食物的食谱，除了法国蓝带猪排（Cordon Bleu）的。\nfn have_recipe(food: Food) -> Option<Food> {\n    match food {\n        Food::CordonBleu => None,\n        _                => Some(food),\n    }\n}\n\n\n// 要做一份好菜，我们需要原材料和食谱。\n// 我们可以借助一系列 `match` 来表达这个逻辑：\nfn cookable_v1(food: Food) -> Option<Food> {\n    match have_ingredients(food) {\n        None       => None,\n        Some(food) => match have_recipe(food) {\n            None       => None,\n            Some(food) => Some(food),\n        },\n    }\n}\n\n// 也可以使用 `and_then()` 把上面的逻辑改写得更紧凑：\nfn cookable_v2(food: Food) -> Option<Food> {\n    have_ingredients(food).and_then(have_recipe)\n}\n\nfn eat(food: Food, day: Day) {\n    match cookable_v2(food) {\n        Some(food) => println!("Yay! On {:?} we get to eat {:?}.", day, food),\n        None       => println!("Oh no. We don\'t get to eat on {:?}?", day),\n    }\n}\n\nfn main() {\n    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);\n\n    eat(cordon_bleu, Day::Monday);\n    eat(steak, Day::Tuesday);\n    eat(sushi, Day::Wednesday);\n}\n')])])]),e("h3",{attrs:{id:"参见："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[o._v("#")]),o._v(" 参见：")]),o._v(" "),e("p",[e("RouterLink",{attrs:{to:"/fn/closures.html"}},[o._v("闭包")]),o._v("，"),e("a",{attrs:{href:"http://doc.rust-lang.org/std/option/enum.Option.html#method.map",target:"_blank",rel:"noopener noreferrer"}},[e("code",[o._v("Option::map()")]),e("OutboundLink")],1),o._v(", 和 "),e("a",{attrs:{href:"http://doc.rust-lang.org/std/option/enum.Option.html#method.and_then",target:"_blank",rel:"noopener noreferrer"}},[e("code",[o._v("Option::and_then()")]),e("OutboundLink")],1)],1)])}),[],!1,null,null,null);n.default=d.exports}}]);