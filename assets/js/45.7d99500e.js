(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{523:function(n,e,o){"use strict";o.r(e);var t=o(4),i=Object(t.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h1",{attrs:{id:"option-和-unwrap"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#option-和-unwrap"}},[n._v("#")]),n._v(" "),o("code",[n._v("Option")]),n._v(" 和 "),o("code",[n._v("unwrap")])]),n._v(" "),o("p",[n._v("上个例子展示了如何主动地引入程序失败（program failure）。当公主收到蛇这件不合适\n的礼物时，我们就让程序 "),o("code",[n._v("panic")]),n._v("。但是，如果公主期待收到礼物，却没收到呢？这同样\n是一件糟糕的事情，所以我们要想办法来解决这个问题！")]),n._v(" "),o("p",[n._v("我们"),o("strong",[n._v("可以")]),n._v("检查空字符串（"),o("code",[n._v('""')]),n._v("），就像处理蛇那样。但既然我们在用 Rust，不如\n让编译器辨别没有礼物的情况。")]),n._v(" "),o("p",[n._v("在标准库（"),o("code",[n._v("std")]),n._v("）中有个叫做 "),o("code",[n._v("Option<T>")]),n._v("（option 中文意思是 “选项”）的枚举\n类型，用于有 “不存在” 的可能性的情况。它表现为以下两个 “option”（选项）中\n的一个：")]),n._v(" "),o("ul",[o("li",[o("code",[n._v("Some(T)")]),n._v("：找到一个属于 "),o("code",[n._v("T")]),n._v(" 类型的元素")]),n._v(" "),o("li",[o("code",[n._v("None")]),n._v("：找不到相应元素")])]),n._v(" "),o("p",[n._v("这些选项可以通过 "),o("code",[n._v("match")]),n._v(" 显式地处理，或使用 "),o("code",[n._v("unwrap")]),n._v(" 隐式地处理。隐式处理要么\n返回 "),o("code",[n._v("Some")]),n._v(" 内部的元素，要么就 "),o("code",[n._v("panic")]),n._v("。")]),n._v(" "),o("p",[n._v("请注意，手动使用 "),o("a",{attrs:{href:"https://doc.rust-lang.org/std/option/enum.Option.html#method.expect",target:"_blank",rel:"noopener noreferrer"}},[n._v("expect"),o("OutboundLink")],1),n._v(" 方法自定义 "),o("code",[n._v("panic")]),n._v(" 信息是可能的，但相比显式\n处理，"),o("code",[n._v("unwrap")]),n._v(" 的输出仍显得不太有意义。在下面例子中，显式处理将举出更受控制的\n结果，同时如果需要的话，仍然可以使程序 "),o("code",[n._v("panic")]),n._v("。")]),n._v(" "),o("div",{staticClass:"language-rust,editable,ignore,mdbook-runnable extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v('// 平民（commoner）们见多识广，收到什么礼物都能应对。\n// 所有礼物都显式地使用 `match` 来处理。\nfn give_commoner(gift: Option<&str>) {\n    // 指出每种情况下的做法。\n    match gift {\n        Some("snake") => println!("Yuck! I\'m throwing that snake in a fire."),\n        Some(inner)   => println!("{}? How nice.", inner),\n        None          => println!("No gift? Oh well."),\n    }\n}\n\n// 养在深闺人未识的公主见到蛇就会 `panic`（恐慌）。\n// 这里所有的礼物都使用 `unwrap` 隐式地处理。\nfn give_princess(gift: Option<&str>) {\n    // `unwrap` 在接收到 `None` 时将返回 `panic`。\n    let inside = gift.unwrap();\n    if inside == "snake" { panic!("AAAaaaaa!!!!"); }\n\n    println!("I love {}s!!!!!", inside);\n}\n\nfn main() {\n    let food  = Some("chicken");\n    let snake = Some("snake");\n    let void  = None;\n\n    give_commoner(food);\n    give_commoner(snake);\n    give_commoner(void);\n\n    let bird = Some("robin");\n    let nothing = None;\n\n    give_princess(bird);\n    give_princess(nothing);\n}\n')])])])])}),[],!1,null,null,null);e.default=i.exports}}]);