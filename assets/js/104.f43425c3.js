(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{583:function(t,n,s){"use strict";s.r(n);var a=s(4),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"显示（display）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#显示（display）"}},[t._v("#")]),t._v(" 显示（Display）")]),t._v(" "),s("p",[s("code",[t._v("fmt::Debug")]),t._v(" 通常看起来不太简洁，因此自定义输出的外观经常是更可取的。这需要通过\n手动实现 "),s("a",{attrs:{href:"https://doc.rust-lang.org/std/fmt/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("fmt::Display")]),s("OutboundLink")],1),t._v(" 来做到。"),s("code",[t._v("fmt::Display")]),t._v(" 采用 "),s("code",[t._v("{}")]),t._v(" 标记。实现方式看\n起来像这样：")]),t._v(" "),s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// （使用 `use`）导入 `fmt` 模块使 `fmt::Display` 可用")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),t._v("fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义一个结构体，咱们会为它实现 `fmt::Display`。以下是个简单的元组结构体")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `Structure`，包含一个 `i32` 元素。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[t._v("Structure")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("i32")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 为了使用 `{}` 标记，必须手动为类型实现 `fmt::Display` trait。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Display")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Structure")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个 trait 要求 `fmt` 使用与下面的函数完全一致的函数签名")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("fmt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Formatter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")])]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Result")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 仅将 self 的第一个元素写入到给定的输出流 `f`。返回 `fmt:Result`，此")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 结果表明操作成功或失败。注意 `write!` 的用法和 `println!` 很相似。")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("write!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"{}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[s("code",[t._v("fmt::Display")]),t._v(" 的效果可能比 "),s("code",[t._v("fmt::Debug")]),t._v(" 简洁，但对于 "),s("code",[t._v("std")]),t._v(" 库来说，这就有一个问\n题。模棱两可的类型该如何显示呢？举个例子，假设标准库对所有的 "),s("code",[t._v("Vec<T>")]),t._v(" 都实现了同\n一种输出样式，那么它应该是哪种样式？下面两种中的一种吗？")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Vec<path>")]),t._v("："),s("code",[t._v("/:/etc:/home/username:/bin")]),t._v("（使用 "),s("code",[t._v(":")]),t._v(" 分割）")]),t._v(" "),s("li",[s("code",[t._v("Vec<number>")]),t._v("："),s("code",[t._v("1,2,3")]),t._v("（使用 "),s("code",[t._v(",")]),t._v(" 分割）")])]),t._v(" "),s("p",[t._v("我们没有这样做，因为没有一种合适的样式适用于所有类型，标准库也并不擅自规定一种样\n式。对于 "),s("code",[t._v("Vec<T>")]),t._v(" 或其他任意泛型容器（generic container），"),s("code",[t._v("fmt::Display")]),t._v(" 都没有\n实现。因此在这些泛型的情况下要用 "),s("code",[t._v("fmt::Debug")]),t._v("。")]),t._v(" "),s("p",[t._v("这并不是一个问题，因为对于任何"),s("strong",[t._v("非")]),t._v("泛型的"),s("strong",[t._v("容器")]),t._v("类型， "),s("code",[t._v("fmt::Display")]),t._v(" 都能够实\n现。")]),t._v(" "),s("div",{staticClass:"language-rust,editable extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('use std::fmt; // 导入 `fmt`\n\n// 带有两个数字的结构体。推导出 `Debug`，以便与 `Display` 的输出进行比较。\n#[derive(Debug)]\nstruct MinMax(i64, i64);\n\n// 实现 `MinMax` 的 `Display`。\nimpl fmt::Display for MinMax {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // 使用 `self.number` 来表示各个数据。\n        write!(f, "({}, {})", self.0, self.1)\n    }\n}\n\n// 为了比较，定义一个含有具名字段的结构体。\n#[derive(Debug)]\nstruct Point2D {\n    x: f64,\n    y: f64,\n}\n\n// 类似地对 `Point2D` 实现 `Display`\nimpl fmt::Display for Point2D {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // 自定义格式，使得仅显示 `x` 和 `y` 的值。\n        write!(f, "x: {}, y: {}", self.x, self.y)\n    }\n}\n\nfn main() {\n    let minmax = MinMax(0, 14);\n\n    println!("Compare structures:");\n    println!("Display: {}", minmax);\n    println!("Debug: {:?}", minmax);\n\n    let big_range =   MinMax(-300, 300);\n    let small_range = MinMax(-3, 3);\n\n    println!("The big range is {big} and the small is {small}",\n             small = small_range,\n             big = big_range);\n\n    let point = Point2D { x: 3.3, y: 7.2 };\n\n    println!("Compare points:");\n    println!("Display: {}", point);\n    println!("Debug: {:?}", point);\n\n    // 报错。`Debug` 和 `Display` 都被实现了，但 `{:b}` 需要 `fmt::Binary`\n    // 得到实现。这语句不能运行。\n    // println!("What does Point2D look like in binary: {:b}?", point);\n}\n')])])]),s("p",[s("code",[t._v("fmt::Display")]),t._v(" 被实现了，而 "),s("code",[t._v("fmt::Binary")]),t._v(" 没有，因此 "),s("code",[t._v("fmt::Binary")]),t._v(" 不能使用。\n"),s("code",[t._v("std::fmt")]),t._v(" 有很多这样的 "),s("RouterLink",{attrs:{to:"/trait.html"}},[s("code",[t._v("trait")])]),t._v("，它们都要求有各自的实现。这些内容将在\n后面的 "),s("a",{attrs:{href:"https://doc.rust-lang.org/std/fmt/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("std::fmt")]),s("OutboundLink")],1),t._v(" 章节中详细介绍。")],1),t._v(" "),s("h3",{attrs:{id:"动手试一试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动手试一试"}},[t._v("#")]),t._v(" 动手试一试")]),t._v(" "),s("p",[t._v("检验上面例子的输出，然后在示例程序中，仿照 "),s("code",[t._v("Point2D")]),t._v(" 结构体增加一个复数结构体。\n使用一样的方式打印，输出结果要求是这个样子：")]),t._v(" "),s("div",{staticClass:"language-txt extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Display: 3.3 + 7.2i\nDebug: Complex { real: 3.3, imag: 7.2 }\n")])])]),s("h3",{attrs:{id:"参见："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/trait/derive.html"}},[s("code",[t._v("derive")])]),t._v(", "),s("a",{attrs:{href:"https://doc.rust-lang.org/std/fmt/",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("std::fmt")]),s("OutboundLink")],1),t._v(", "),s("RouterLink",{attrs:{to:"/macros.html"}},[t._v("macros")]),t._v(", "),s("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[s("code",[t._v("struct")])]),t._v(",\n"),s("RouterLink",{attrs:{to:"/trait.html"}},[s("code",[t._v("trait")])]),t._v(", 和 "),s("RouterLink",{attrs:{to:"/mod/use.html"}},[t._v("use")])],1)])}),[],!1,null,null,null);n.default=e.exports}}]);