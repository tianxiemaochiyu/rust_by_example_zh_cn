(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{648:function(t,a,n){"use strict";n.r(a);var s=n(4),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"文件系统操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文件系统操作"}},[t._v("#")]),t._v(" 文件系统操作")]),t._v(" "),n("p",[n("code",[t._v("std::io::fs")]),t._v(" 模块包含几个处理文件系统的函数。")]),t._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('use std::fs;\nuse std::fs::{File, OpenOptions};\nuse std::io;\nuse std::io::prelude::*;\nuse std::os::unix;\nuse std::path::Path;\n\n// `% cat path` 的简单实现\nfn cat(path: &Path) -> io::Result<String> {\n    let mut f = try!(File::open(path));\n    let mut s = String::new();\n    match f.read_to_string(&mut s) {\n        Ok(_) => Ok(s),\n        Err(e) => Err(e),\n    }\n}\n\n// `% echo s > path` 的简单实现\nfn echo(s: &str, path: &Path) -> io::Result<()> {\n    let mut f = try!(File::create(path));\n\n    f.write_all(s.as_bytes())\n}\n\n// `% touch path` 的简单实现（忽略已存在的文件）\nfn touch(path: &Path) -> io::Result<()> {\n    match OpenOptions::new().create(true).write(true).open(path) {\n        Ok(_) => Ok(()),\n        Err(e) => Err(e),\n    }\n}\n\nfn main() {\n    println!("`mkdir a`");\n    // 创建一个目录，返回 `io::Result<()>`\n    match fs::create_dir("a") {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(_) => {},\n    }\n\n    println!("`echo hello > a/b.txt`");\n    // 前面的匹配可以用 `unwrap_or_else` 方法简化\n    echo("hello", &Path::new("a/b.txt")).unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`mkdir -p a/c/d`");\n    // 递归地创建一个目录，返回 `io::Result<()>`\n    fs::create_dir_all("a/c/d").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`touch a/c/e.txt`");\n    touch(&Path::new("a/c/e.txt")).unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`ln -s ../b.txt a/c/b.txt`");\n    // 创建一个符号链接，返回 `io::Resutl<()>`\n    if cfg!(target_family = "unix") {\n        unix::fs::symlink("../b.txt", "a/c/b.txt").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n        });\n    }\n\n    println!("`cat a/c/b.txt`");\n    match cat(&Path::new("a/c/b.txt")) {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(s) => println!("> {}", s),\n    }\n\n    println!("`ls a`");\n    // 读取目录的内容，返回 `io::Result<Vec<Path>>`\n    match fs::read_dir("a") {\n        Err(why) => println!("! {:?}", why.kind()),\n        Ok(paths) => for path in paths {\n            println!("> {:?}", path.unwrap().path());\n        },\n    }\n\n    println!("`rm a/c/e.txt`");\n    // 删除一个文件，返回 `io::Result<()>`\n    fs::remove_file("a/c/e.txt").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n\n    println!("`rmdir a/c/d`");\n    // 移除一个空目录，返回 `io::Result<()>`\n    fs::remove_dir("a/c/d").unwrap_or_else(|why| {\n        println!("! {:?}", why.kind());\n    });\n}\n')])])]),n("p",[t._v("下面是所期望的成功的输出：")]),t._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[t._v("$ rustc fs.rs "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" ./fs\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("mkdir")]),t._v(" a"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" hello "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a/b.txt"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("mkdir")]),t._v(" -p a/c/d"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("touch")]),t._v(" a/c/e.txt"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("ln")]),t._v(" -s "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("/b.txt a/c/b.txt"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" a/c/b.txt"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" hello\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("ls")]),t._v(" a"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a/b.txt\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a/c\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),t._v("walk a"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a/c\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a/c/b.txt\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a/c/e.txt\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a/c/d\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" a/b.txt\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" a/c/e.txt"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token variable"}},[n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("rmdir")]),t._v(" a/c/d"),n("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n")])])]),n("p",[t._v("且 "),n("code",[t._v("a")]),t._v(" 目录的最终状态为：")]),t._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("$ tree a\na\n|-- b.txt\n`-- c\n    `-- b.txt -> ../b.txt\n\n1 directory, 2 files\n")])])]),n("p",[t._v("另一种定义 "),n("code",[t._v("cat")]),t._v(" 函数的方式是使用 "),n("code",[t._v("?")]),t._v(" 标记：")]),t._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("fn cat(path: &Path) -> io::Result<String> {\n    let mut f = File::open(path)?;\n    let mut s = String::new();\n    f.read_to_string(&mut s)?;\n    Ok(s)\n}\n")])])]),n("h3",{attrs:{id:"参见："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),n("p",[n("RouterLink",{attrs:{to:"/attribute/cfg.html"}},[n("code",[t._v("cfg!")])])],1)])}),[],!1,null,null,null);a.default=e.exports}}]);