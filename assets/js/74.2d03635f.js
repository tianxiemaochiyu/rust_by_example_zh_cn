(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{550:function(t,n,a){"use strict";a.r(n);var s=a(4),e=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"类型匿名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型匿名"}},[t._v("#")]),t._v(" 类型匿名")]),t._v(" "),a("p",[t._v("闭包从周围的作用域中捕获变量是简单明了的。这样会有某些后果吗？确实有。观察一下\n使用闭包作为函数参数，这要求闭包是"),a("RouterLink",{attrs:{to:"/generics.html"}},[t._v("泛型")]),t._v("的，闭包定义的方式决定了这是\n必要的。")],1),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `F` 必须是泛型的。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("apply")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("F")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("F")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("F")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FnOnce")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("当闭包被定义，编译器会隐式地创建一个匿名类型的结构体，用以储存闭包捕获的\n变量，同时为这个未知类型的结构体实现函数功能，通过 "),a("code",[t._v("Fn")]),t._v("、"),a("code",[t._v("FnMut")]),t._v(" 或 "),a("code",[t._v("FnOnce")]),t._v("\n三种 "),a("code",[t._v("trait")]),t._v(" 中的一种。")]),t._v(" "),a("p",[t._v("若使用闭包作为函数参数，由于这个结构体的类型未知，任何的用法都要求是泛型的。然\n而，使用未限定类型的参数 "),a("code",[t._v("<T>")]),t._v(" 过于不明确，并且是不允许的。事实上，指明为该\n结构体实现的是 "),a("code",[t._v("Fn")]),t._v("、"),a("code",[t._v("FnMut")]),t._v("、或 "),a("code",[t._v("FnOnce")]),t._v(" 中的哪种 "),a("code",[t._v("trait")]),t._v("，对于约束该结构体的\n类型而言就已经足够了。")]),t._v(" "),a("div",{staticClass:"language-rust,editable extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// `F` 必须为一个没有输入参数和返回值的闭包实现 `Fn`，这和对 `print` 的\n// 要求恰好一样。\nfn apply<F>(f: F) where\n    F: Fn() {\n    f();\n}\n\nfn main() {\n    let x = 7;\n\n    // 捕获 `x` 到匿名类型中，并为它实现 `Fn`。\n    // 将闭包存储到 `print` 中。\n    let print = || println!("{}", x);\n\n    apply(print);\n}\n')])])]),a("h3",{attrs:{id:"参见："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://huonw.github.io/blog/2015/05/finding-closure-in-rust/",target:"_blank",rel:"noopener noreferrer"}},[t._v("详尽分析"),a("OutboundLink")],1),t._v(", "),a("a",{attrs:{href:"https://doc.rust-lang.org/std/ops/trait.Fn.html",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("Fn")]),a("OutboundLink")],1),t._v(", "),a("a",{attrs:{href:"https://doc.rust-lang.org/std/ops/trait.FnMut.html",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("FnMut")]),a("OutboundLink")],1),t._v(",\n和 "),a("a",{attrs:{href:"https://doc.rust-lang.org/std/ops/trait.FnOnce.html",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("FnOnce")]),a("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=e.exports}}]);