(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{587:function(t,e,s){"use strict";s.r(e);var r=s(4),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"测试实例：list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#测试实例：list"}},[t._v("#")]),t._v(" 测试实例：List")]),t._v(" "),s("p",[t._v("对一个结构体实现 "),s("code",[t._v("fmt::Display")]),t._v("，其中的元素需要一个接一个地处理到，这可能会很麻\n烦。问题在于每个 "),s("code",[t._v("write!")]),t._v(" 都要生成一个 "),s("code",[t._v("fmt::Result")]),t._v("。正确的实现需要\n处理"),s("strong",[t._v("所有")]),t._v("的 Result。Rust 专门为解决这个问题提供了 "),s("code",[t._v("?")]),t._v(" 操作符。")]),t._v(" "),s("p",[t._v("在 "),s("code",[t._v("write!")]),t._v(" 上使用 "),s("code",[t._v("?")]),t._v(" 会像是这样：")]),t._v(" "),s("div",{staticClass:"language-rust,ignore extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('// 对 `write!` 进行尝试（try），观察是否出错。若发生错误，返回相应的错误。\n// 否则（没有出错）继续执行后面的语句。\nwrite!(f, "{}", value)?;\n')])])]),s("p",[t._v("另外，你也可以使用 "),s("code",[t._v("try!")]),t._v(" 宏，它和 "),s("code",[t._v("?")]),t._v(" 是一样的。这种写法比较罗嗦，故不再推荐，\n但在老一些的 Rust 代码中仍会看到。使用 "),s("code",[t._v("try!")]),t._v(" 看起来像这样：")]),t._v(" "),s("div",{staticClass:"language-rust,ignore extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('try!(write!(f, "{}", value));\n')])])]),s("p",[t._v("有了 "),s("code",[t._v("?")]),t._v("，对一个 "),s("code",[t._v("Vec")]),t._v(" 实现 "),s("code",[t._v("fmt::Display")]),t._v(" 就很简单了：")]),t._v(" "),s("div",{staticClass:"language-rust,editable extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('use std::fmt; // 导入 `fmt` 模块。\n\n// 定义一个包含单个 `Vec` 的结构体 `List`。\nstruct List(Vec<i32>);\n\nimpl fmt::Display for List {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // 使用元组的下标获取值，并创建一个 `vec` 的引用。\n        let vec = &self.0;\n\n        write!(f, "[")?;\n\n        // 使用 `v` 对 `vec` 进行迭代，并用 `count` 记录迭代次数。\n        for (count, v) in vec.iter().enumerate() {\n            // 对每个元素（第一个元素除外）加上逗号。\n            // 使用 `?` 或 `try!` 来返回错误。\n            if count != 0 { write!(f, ", ")?; }\n            write!(f, "{}", v)?;\n        }\n\n        // 加上配对中括号，并返回一个 fmt::Result 值。\n        write!(f, "]")\n    }\n}\n\nfn main() {\n    let v = List(vec![1, 2, 3]);\n    println!("{}", v);\n}\n')])])]),s("h3",{attrs:{id:"动手试一试："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动手试一试："}},[t._v("#")]),t._v(" 动手试一试：")]),t._v(" "),s("p",[t._v("更改程序使 vector 里面每个元素的下标也能够打印出来。新的结果如下：")]),t._v(" "),s("div",{staticClass:"language-rust,ignore extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("[0: 1, 1: 2, 2: 3]\n")])])]),s("h3",{attrs:{id:"参见："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/flow_control/for.html"}},[s("code",[t._v("for")])]),t._v(", "),s("RouterLink",{attrs:{to:"/scope/borrow/ref.html"}},[s("code",[t._v("ref")])]),t._v(", "),s("RouterLink",{attrs:{to:"/std/result.html"}},[s("code",[t._v("Result")])]),t._v(", "),s("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[s("code",[t._v("struct")])]),t._v(",\n"),s("RouterLink",{attrs:{to:"/std/result/question_mark.html"}},[s("code",[t._v("?")])]),t._v(", 和 "),s("RouterLink",{attrs:{to:"/std/vec.html"}},[s("code",[t._v("vec!")])])],1)])}),[],!1,null,null,null);e.default=n.exports}}]);