(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{624:function(n,t,a){"use strict";a.r(t);var e=a(4),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"所有权和移动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有权和移动"}},[n._v("#")]),n._v(" 所有权和移动")]),n._v(" "),a("p",[n._v("因为变量要负责释放它们拥有的资源，所以"),a("strong",[n._v("资源只能拥有一个所有者")]),n._v("。这也防止了\n资源的重复释放。注意并非所有变量都拥有资源（例如"),a("RouterLink",{attrs:{to:"/flow_control/match/destructuring/destructure_pointers.html"}},[n._v("引用")]),n._v("）。")],1),n._v(" "),a("p",[n._v("在进行赋值（"),a("code",[n._v("let x = y")]),n._v("）或通过值来传递函数参数（"),a("code",[n._v("foo(x)")]),n._v("）的时候，资源\n的"),a("strong",[n._v("所有权")]),n._v("（ownership）会发生转移。按照 Rust 的说法，这被称为资源\n的"),a("strong",[n._v("移动")]),n._v("（move）。")]),n._v(" "),a("p",[n._v("在移动资源之后，原来的所有者不能再被使用，这可避免悬挂指针（dangling\npointer）的产生。")]),n._v(" "),a("div",{staticClass:"language-rust,editable extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 此函数取得堆分配的内存的所有权\nfn destroy_box(c: Box<i32>) {\n    println!("Destroying a box that contains {}", c);\n\n    // `c` 被销毁且内存得到释放\n}\n\nfn main() {\n    // 栈分配的整型\n    let x = 5u32;\n\n    // 将 `x` *复制*到 `y`——不存在资源移动\n    let y = x;\n\n    // 两个值各自都可以使用\n    println!("x is {}, and y is {}", x, y);\n\n    // `a` 是一个指向堆分配的整数的指针\n    let a = Box::new(5i32);\n\n    println!("a contains: {}", a);\n\n    // *移动* `a` 到 `b`\n    let b = a;\n    // 把 `a` 的指针地址（而非数据）复制到 `b`。现在两者都指向\n    // 同一个堆分配的数据，但是现在是 `b` 拥有它。\n    \n    // 报错！`a` 不能访问数据，因为它不再拥有那部分堆上的内存。\n    //println!("a contains: {}", a);\n    // 试一试 ^ 去掉此行注释\n\n    // 此函数从 `b` 中取得堆分配的内存的所有权\n    destroy_box(b);\n\n    // 此时堆内存已经被释放，这个操作会导致解引用已释放的内存，而这是编译器禁止的。\n    // 报错！和前面出错的原因一样。\n    //println!("b contains: {}", b);\n    // 试一试 ^ 去掉此行注释\n}\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);