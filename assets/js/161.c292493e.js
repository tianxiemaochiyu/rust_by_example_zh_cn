(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{640:function(n,e,t){"use strict";t.r(e);var s=t(4),r=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"外部语言函数接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#外部语言函数接口"}},[n._v("#")]),n._v(" 外部语言函数接口")]),n._v(" "),t("p",[n._v("Rust 提供了到 C 语言库的外部语言函数接口（Foreign Function Interface，FFI）。外\n部语言函数必须在一个 "),t("code",[n._v("extern")]),n._v(" 代码块中声明，且该代码块要带有一个包含库名称\n的 "),t("code",[n._v("#[link]")]),n._v(" 属性。")]),n._v(" "),t("div",{staticClass:"language-rust,ignore extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('use std::fmt;\n\n// 这个 extern 代码块链接到 libm 库\n#[link(name = "m")]\nextern {\n    // 这个外部函数用于计算单精度复数的平方根\n    fn csqrtf(z: Complex) -> Complex;\n\n    // 这个用来计算单精度复数的复变余弦\n    fn ccosf(z: Complex) -> Complex;\n}\n\n// 由于调用其他语言的函数被认为是不安全的，我们通常会给它们写一层安全的封装\nfn cos(z: Complex) -> Complex {\n    unsafe { ccosf(z) }\n}\n\nfn main() {\n    // z = -1 + 0i\n    let z = Complex { re: -1., im: 0. };\n\n    // 调用外部语言函数是不安全操作\n    let z_sqrt = unsafe { csqrtf(z) };\n\n    println!("the square root of {:?} is {:?}", z, z_sqrt);\n\n    // 调用不安全操作的安全的 API 封装\n    println!("cos({:?}) = {:?}", z, cos(z));\n}\n\n// 单精度复数的最简实现\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct Complex {\n    re: f32,\n    im: f32,\n}\n\nimpl fmt::Debug for Complex {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.im < 0. {\n            write!(f, "{}-{}i", self.re, -self.im)\n        } else {\n            write!(f, "{}+{}i", self.re, self.im)\n        }\n    }\n}\n')])])])])}),[],!1,null,null,null);e.default=r.exports}}]);