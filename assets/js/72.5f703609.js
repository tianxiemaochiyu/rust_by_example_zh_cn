(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{548:function(n,e,i){"use strict";i.r(e);var t=i(4),s=Object(t.a)({},(function(){var n=this,e=n.$createElement,i=n._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h1",{attrs:{id:"函数"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[n._v("#")]),n._v(" 函数")]),n._v(" "),i("p",[n._v("函数（function）使用 "),i("code",[n._v("fn")]),n._v(" 关键字来声明。函数的参数需要标注类型，就和变量\n一样，另外如果函数返回一个值，返回类型必须在箭头 "),i("code",[n._v("->")]),n._v(" 之后指定。")]),n._v(" "),i("p",[n._v("函数最后的表达式将作为返回值。也可在函数内使用 "),i("code",[n._v("return")]),n._v(" 语句来提前返回值。"),i("code",[n._v("return")]),n._v("\n甚至也可在循环或 "),i("code",[n._v("if")]),n._v(" 内部使用。")]),n._v(" "),i("p",[n._v("让我们使用函数来重写 FizzBuzz 程序吧！")]),n._v(" "),i("div",{staticClass:"language-rust,editable extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('// 和 C/C++ 不一样，Rust 的函数定义位置是没有限制的\nfn main() {\n    // 我们可以在这里使用函数，后面再定义它\n    fizzbuzz_to(100);\n}\n\n// 一个返回布尔值的函数\nfn is_divisible_by(lhs: u32, rhs: u32) -> bool {\n    // 边界情况，提前返回\n    if rhs == 0 {\n        return false;\n    }\n\n    // 这是一个表达式，这里可以不用 `return` 关键字\n    lhs % rhs == 0\n}\n\n// 一个 “不” 返回值的函数。实际上会返回一个单元类型 `()`。\nfn fizzbuzz(n: u32) -> () {\n    if is_divisible_by(n, 15) {\n        println!("fizzbuzz");\n    } else if is_divisible_by(n, 3) {\n        println!("fizz");\n    } else if is_divisible_by(n, 5) {\n        println!("buzz");\n    } else {\n        println!("{}", n);\n    }\n}\n\n// 当函数返回 `()` 时，函数签名可以省略返回类型\nfn fizzbuzz_to(n: u32) {\n    for n in 1..n + 1 {\n        fizzbuzz(n);\n    }\n}\n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);