(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{510:function(e,n,t){"use strict";t.r(n);var a=t(4),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"枚举"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#枚举"}},[e._v("#")]),e._v(" 枚举")]),e._v(" "),t("p",[t("code",[e._v("enum")]),e._v(" 关键字可以创建枚举类型（enumeration），该类型的实例只能在数个可能的取值中\n取一种。任何一个合法的 "),t("code",[e._v("struct")]),e._v(" 同时也是合法的 "),t("code",[e._v("enum")]),e._v(" 取值。")]),e._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 该属性用于隐藏对未使用代码的警告。\n#![allow(dead_code)]\n\n// 创建一个 `enum`（枚举）来对 web 事件分类。注意变量名和类型共同指定了 `enum`\n// 取值的种类：`PageLoad` 不等于 `PageUnload`，`KeyPress(char)` 不等于\n// `Paste(String)`。各个取值不同，互相独立。\nenum WebEvent {\n    // 一个 `enum` 可以是单元结构体（称为 `unit-like` 或 `unit`），\n    PageLoad,\n    PageUnload,\n    // 或者一个元组结构体，\n    KeyPress(char),\n    Paste(String),\n    // 或者一个普通的结构体。\n    Click { x: i64, y: i64 }\n}\n\n// 此函数将一个 `WebEvent` enum 作为参数，无返回值。\nfn inspect(event: WebEvent) {\n    match event {\n        WebEvent::PageLoad => println!("page loaded"),\n        WebEvent::PageUnload => println!("page unloaded"),\n        // 从 `enum` 里解构出 `c`。\n        WebEvent::KeyPress(c) => println!("pressed \'{}\'.", c),\n        WebEvent::Paste(s) => println!("pasted \\"{}\\".", s),\n        // 把 `Click` 解构给 `x` and `y`。\n        WebEvent::Click { x, y } => {\n            println!("clicked at x={}, y={}.", x, y);\n        },\n    }\n}\n\nfn main() {\n    let pressed = WebEvent::KeyPress(\'x\');\n    // `to_owned()` 从一个字符串切片中创建一个具有所有权的 `String`。\n    let pasted  = WebEvent::Paste("my text".to_owned());\n    let click   = WebEvent::Click { x: 20, y: 80 };\n    let load    = WebEvent::PageLoad;\n    let unload  = WebEvent::PageUnload;\n\n    inspect(pressed);\n    inspect(pasted);\n    inspect(click);\n    inspect(load);\n    inspect(unload);\n}\n')])])]),t("h2",{attrs:{id:"类型别名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型别名"}},[e._v("#")]),e._v(" 类型别名")]),e._v(" "),t("p",[e._v("若使用类型别名，则可以通过其别名引用每个枚举变量。当枚举的名称太长或者太一般化，且你想要对其重命名，那么这对你会有所帮助。")]),e._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("enum VeryVerboseEnumOfThingsToDoWithNumbers {\n    Add,\n    Subtract,\n}\n\n// Creates a type alias\ntype Operations = VeryVerboseEnumOfThingsToDoWithNumbers;\n\nfn main() {\n    // We can refer to each variant via its alias, not its long and inconvenient\n    // name.\n    let x = Operations::Add;\n}\n")])])]),t("p",[e._v("最常见的情况就是在 "),t("code",[e._v("impl")]),e._v(" 块中使用 "),t("code",[e._v("Self")]),e._v(" 别名。")]),e._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("enum VeryVerboseEnumOfThingsToDoWithNumbers {\n    Add,\n    Subtract,\n}\n\nimpl VeryVerboseEnumOfThingsToDoWithNumbers {\n    fn run(&self, x: i32, y: i32) -> i32 {\n        match self {\n            Self::Add => x + y,\n            Self::Subtract => x - y,\n        }\n    }\n}\n")])])]),t("p",[e._v("该功能已在 Rust 中稳定化， 可以阅读 [stabilization report][aliasreport] 来了解更多有关枚举和类型别名的知识。")]),e._v(" "),t("h3",{attrs:{id:"参见："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[e._v("#")]),e._v(" 参见：")]),e._v(" "),t("p",[t("RouterLink",{attrs:{to:"/flow_control/match.html"}},[t("code",[e._v("match")])]),e._v(", "),t("RouterLink",{attrs:{to:"/fn.html"}},[t("code",[e._v("fn")])]),e._v(", 和 "),t("RouterLink",{attrs:{to:"/std/str.html"}},[t("code",[e._v("String")])]),e._v(', ["Type alias enum variants" RFC][type_alias_rfc]')],1)])}),[],!1,null,null,null);n.default=s.exports}}]);