(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{663:function(r,t,o){"use strict";o.r(t);var n=o(4),a=Object(n.a)({},(function(){var r=this,t=r.$createElement,o=r._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[o("h1",{attrs:{id:"运算符重载"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#运算符重载"}},[r._v("#")]),r._v(" 运算符重载")]),r._v(" "),o("p",[r._v("在 Rust 中，很多运算符可以通过 trait 来重载。也就是说，这些运算符可以根据它们的\n输入参数来完成不同的任务。这之所以可行，是因为运算符就是方法调用的语法糖。例\n如，"),o("code",[r._v("a + b")]),r._v(" 中的 "),o("code",[r._v("+")]),r._v(" 运算符会调用 "),o("code",[r._v("add")]),r._v(" 方法（也就是 "),o("code",[r._v("a.add(b)")]),r._v("）。这个 "),o("code",[r._v("add")]),r._v(" 方\n法是 "),o("code",[r._v("Add")]),r._v(" trait 的一部分。因此，"),o("code",[r._v("+")]),r._v(" 运算符可以被任何 "),o("code",[r._v("Add")]),r._v(" trait 的实现者使用。")]),r._v(" "),o("p",[r._v("会重载运算符的 "),o("code",[r._v("trait")]),r._v("（比如 "),o("code",[r._v("Add")]),r._v(" 这种）可以在"),o("a",{attrs:{href:"http://doc.rust-lang.org/core/ops/",target:"_blank",rel:"noopener noreferrer"}},[r._v("这里"),o("OutboundLink")],1),r._v("查看。")]),r._v(" "),o("div",{staticClass:"language-rust,editable extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[r._v('use std::ops;\n\nstruct Foo;\nstruct Bar;\n\n#[derive(Debug)]\nstruct FooBar;\n\n#[derive(Debug)]\nstruct BarFoo;\n\n// `std::ops::Add` trait 用来指明 `+` 的功能，这里我们实现 `Add<Bar>`，它是用于\n// 把对象和 `Bar` 类型的右操作数（RHS）加起来的 `trait`。\n// 下面的代码块实现了 `Foo + Bar = FooBar` 这样的运算。\nimpl ops::Add<Bar> for Foo {\n    type Output = FooBar;\n\n    fn add(self, _rhs: Bar) -> FooBar {\n        println!("> Foo.add(Bar) was called");\n\n        FooBar\n    }\n}\n\n// 通过颠倒类型，我们实现了不服从交换律的加法。\n// 这里我们实现 `Add<Foo>`，它是用于把对象和 `Foo` 类型的右操作数加起来的 trait。\n// 下面的代码块实现了 `Bar + Foo = BarFoo` 这样的运算。\nimpl ops::Add<Foo> for Bar {\n    type Output = BarFoo;\n\n    fn add(self, _rhs: Foo) -> BarFoo {\n        println!("> Bar.add(Foo) was called");\n\n        BarFoo\n    }\n}\n\nfn main() {\n    println!("Foo + Bar = {:?}", Foo + Bar);\n    println!("Bar + Foo = {:?}", Bar + Foo);\n}\n')])])]),o("h3",{attrs:{id:"参见："}},[o("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[r._v("#")]),r._v(" 参见：")]),r._v(" "),o("p",[o("a",{attrs:{href:"http://doc.rust-lang.org/core/ops/trait.Add.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("Add"),o("OutboundLink")],1),r._v(", "),o("a",{attrs:{href:"https://doc.rust-lang.org/book/syntax-index.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("语法索引"),o("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);