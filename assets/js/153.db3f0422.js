(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{631:function(n,e,t){"use strict";t.r(e);var r=t(4),a=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"结果-result"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结果-result"}},[n._v("#")]),n._v(" 结果 "),t("code",[n._v("Result")])]),n._v(" "),t("p",[n._v("我们已经看到 "),t("code",[n._v("Option")]),n._v(" 枚举类型可以用作可能失败的函数的返回值，其中返回 "),t("code",[n._v("None")]),n._v("\n可以表明失败。但是有时要强调"),t("strong",[n._v("为什么")]),n._v("一个操作会失败。为做到这点，我们提供\n了 "),t("code",[n._v("Result")]),n._v(" 枚举类型。")]),n._v(" "),t("p",[t("code",[n._v("Result<T, E>")]),n._v(" 类型拥有两个取值：")]),n._v(" "),t("ul",[t("li",[t("code",[n._v("Ok(value)")]),n._v(" 表示操作成功，并包装操作返回的 "),t("code",[n._v("value")]),n._v("（"),t("code",[n._v("value")]),n._v(" 拥有 "),t("code",[n._v("T")]),n._v(" 类型）。")]),n._v(" "),t("li",[t("code",[n._v("Err(why)")]),n._v("，表示操作失败，并包装 "),t("code",[n._v("why")]),n._v("，它（但愿）能够解释失败的原因（"),t("code",[n._v("why")]),n._v("\n拥有 "),t("code",[n._v("E")]),n._v(" 类型）。")])]),n._v(" "),t("div",{staticClass:"language-rust,editalbe,ignore,mdbook-runnable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('mod checked {\n    // 我们想要捕获的数学 “错误”\n    #[derive(Debug)]\n    pub enum MathError {\n        DivisionByZero,\n        NegativeLogarithm,\n        NegativeSquareRoot,\n    }\n\n    pub type MathResult = Result<f64, MathError>;\n\n    pub fn div(x: f64, y: f64) -> MathResult {\n        if y == 0.0 {\n            // 此操作将会失败，那么（与其让程序崩溃）不如把失败的原因包装在\n            // `Err` 中并返回\n            Err(MathError::DivisionByZero)\n        } else {\n            // 此操作是有效的，返回包装在 `Ok` 中的结果\n            Ok(x / y)\n        }\n    }\n\n    pub fn sqrt(x: f64) -> MathResult {\n        if x < 0.0 {\n            Err(MathError::NegativeSquareRoot)\n        } else {\n            Ok(x.sqrt())\n        }\n    }\n\n    pub fn ln(x: f64) -> MathResult {\n        if x < 0.0 {\n            Err(MathError::NegativeLogarithm)\n        } else {\n            Ok(x.ln())\n        }\n    }\n}\n\n// `op(x, y)` === `sqrt(ln(x / y))`\nfn op(x: f64, y: f64) -> f64 {\n    // 这是一个三层的 match 金字塔！\n    match checked::div(x, y) {\n        Err(why) => panic!("{:?}", why),\n        Ok(ratio) => match checked::ln(ratio) {\n            Err(why) => panic!("{:?}", why),\n            Ok(ln) => match checked::sqrt(ln) {\n                Err(why) => panic!("{:?}", why),\n                Ok(sqrt) => sqrt,\n            },\n        },\n    }\n}\n\nfn main() {\n    // 这会失败吗？\n    println!("{}", op(1.0, 10.0));\n}\n')])])])])}),[],!1,null,null,null);e.default=a.exports}}]);