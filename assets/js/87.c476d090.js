(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{567:function(n,t,e){"use strict";e.r(t);var r=e(4),i=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"存在问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[n._v("#")]),n._v(" 存在问题")]),n._v(" "),e("p",[e("code",[n._v("trait")]),n._v(" 如果对实现了它的容器类型是泛型的，则须遵守类型规范要求——"),e("code",[n._v("trait")]),n._v(" 的\n使用者"),e("strong",[n._v("必须")]),n._v("指出 "),e("code",[n._v("trait")]),n._v(" 的全部泛型类型。")]),n._v(" "),e("p",[n._v("在下面例子中，"),e("code",[n._v("Contains")]),n._v(" "),e("code",[n._v("trait")]),n._v(" 允许使用泛型类型 "),e("code",[n._v("A")]),n._v(" 或 "),e("code",[n._v("B")]),n._v("。然后我们为\n"),e("code",[n._v("Container")]),n._v(" 类型实现了这个 trait，将 "),e("code",[n._v("A")]),n._v(" 和 "),e("code",[n._v("B")]),n._v(" 指定为 "),e("code",[n._v("i32")]),n._v("，这样就可以对\n它们使用 "),e("code",[n._v("difference()")]),n._v(" 函数。")]),n._v(" "),e("p",[n._v("因为 "),e("code",[n._v("Contains")]),n._v(" 是泛型的，我们必须在 "),e("code",[n._v("fn difference()")]),n._v(" 中显式地指出"),e("strong",[n._v("所有的")]),n._v("泛型\n类型。但实际上，我们想要表达，"),e("code",[n._v("A")]),n._v(" 和 "),e("code",[n._v("B")]),n._v(" 究竟是什么类型是由输入 "),e("code",[n._v("C")]),n._v(" 决定的。在\n下一节会看到，关联类型恰好提供了这样的功能。")]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('struct Container(i32, i32);\n\n// 这个 trait 检查给定的 2 个项是否储存于容器中\n// 并且能够获得容器的第一个或最后一个值。\ntrait Contains<A, B> {\n    fn contains(&self, _: &A, _: &B) -> bool; // 显式地要求 `A` 和 `B`\n    fn first(&self) -> i32; // 未显式地要求 `A` 或 `B`\n    fn last(&self) -> i32;  // 未显式地要求 `A` 或 `B`\n}\n\nimpl Contains<i32, i32> for Container {\n    // 如果存储的数字和给定的相等则为真。\n    fn contains(&self, number_1: &i32, number_2: &i32) -> bool {\n        (&self.0 == number_1) && (&self.1 == number_2)\n    }\n\n    // 得到第一个数字。\n    fn first(&self) -> i32 { self.0 }\n\n    // 得到最后一个数字。\n    fn last(&self) -> i32 { self.1 }\n}\n\n// 容器 `C` 就包含了 `A` 和 `B` 类型。鉴于此，必须指出 `A` 和 `B` 显得很麻烦。\nfn difference<A, B, C>(container: &C) -> i32 where\n    C: Contains<A, B> {\n    container.last() - container.first()\n}\n\nfn main() {\n    let number_1 = 3;\n    let number_2 = 10;\n\n    let container = Container(number_1, number_2);\n\n    println!("Does container contain {} and {}: {}",\n        &number_1, &number_2,\n        container.contains(&number_1, &number_2));\n    println!("First number: {}", container.first());\n    println!("Last number: {}", container.last());\n\n    println!("The difference is: {}", difference(&container));\n}\n')])])]),e("h3",{attrs:{id:"参见："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[n._v("#")]),n._v(" 参见：")]),n._v(" "),e("p",[e("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[e("code",[n._v("struct")])]),n._v(", 和 "),e("RouterLink",{attrs:{to:"/trait.html"}},[e("code",[n._v("trait")])])],1)])}),[],!1,null,null,null);t.default=i.exports}}]);