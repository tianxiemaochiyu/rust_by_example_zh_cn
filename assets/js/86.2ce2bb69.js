(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{565:function(t,e,r){"use strict";r.r(e);var a=r(4),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"关联项"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#关联项"}},[t._v("#")]),t._v(" 关联项")]),t._v(" "),r("p",[t._v("“关联项”（associated item）指与多种类型的"),r("a",{attrs:{href:"http://doc.rust-lang.org/reference.html#items",target:"_blank",rel:"noopener noreferrer"}},[t._v("项"),r("OutboundLink")],1),t._v("有关的一组规则。它是 "),r("code",[t._v("trait")]),t._v("\n泛型的扩展，允许在 "),r("code",[t._v("trait")]),t._v(" 内部定义新的项。")]),t._v(" "),r("p",[t._v("一个这样的项就叫做一个关联类型。当 "),r("code",[t._v("trait")]),t._v(" 对于实现了它的容器类型是泛型的，关联\n项就提供了简单的使用方法。")]),t._v(" "),r("blockquote",[r("p",[t._v("译注：「关联项」这个说法实际上只在 RFC 里出现了，官方的《The Rust Programming\nLanguage》第一版和第二版都只有「关联类型」的说法。如果觉得这里的说法很别扭的话\n不要理会就是了。TRPL 对关联类型的定义是：「一种将类型占位符与 trait 联系起来的\n做法，这样 trait 中的方法签名中就可以使用这些占位符类型。trait 的实现会指定在\n该实现中那些占位符对应什么具体类型。」等看完这一节再回头看这个定义就很明白了。")])]),t._v(" "),r("h3",{attrs:{id:"参见："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);