(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{531:function(o,e,n){"use strict";n.r(e);var t=n(4),p=Object(t.a)({},(function(){var o=this,e=o.$createElement,n=o._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[n("h1",{attrs:{id:"组合算子：map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组合算子：map"}},[o._v("#")]),o._v(" 组合算子："),n("code",[o._v("map")])]),o._v(" "),n("p",[n("code",[o._v("match")]),o._v(" 是处理 "),n("code",[o._v("Option")]),o._v(" 的一个可用的方法，但你会发现大量使用它会很繁琐，特别是当\n操作只对一种输入是有效的时。这时，可以使用"),n("a",{attrs:{href:"https://doc.rust-lang.org/book/glossary.html#combinators",target:"_blank",rel:"noopener noreferrer"}},[o._v("组合算子"),n("OutboundLink")],1),o._v("（combinator），以\n模块化的风格来管理控制流。")]),o._v(" "),n("p",[n("code",[o._v("Option")]),o._v(" 有一个内置方法 "),n("code",[o._v("map()")]),o._v("，这个组合算子可用于 "),n("code",[o._v("Some -> Some")]),o._v(" 和\n"),n("code",[o._v("None -> None")]),o._v(" 这样的简单映射。多个不同的 "),n("code",[o._v("map()")]),o._v(" 调用可以串起来，这样更加灵活。")]),o._v(" "),n("p",[o._v("在下面例子中，"),n("code",[o._v("process()")]),o._v(" 轻松取代了前面的所有函数，且更加紧凑。")]),o._v(" "),n("div",{staticClass:"language-rust,editable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v('#![allow(dead_code)]\n\n#[derive(Debug)] enum Food { Apple, Carrot, Potato }\n\n#[derive(Debug)] struct Peeled(Food);\n#[derive(Debug)] struct Chopped(Food);\n#[derive(Debug)] struct Cooked(Food);\n\n// 削皮。如果没有食物，就返回 `None`。否则返回削好皮的食物。\nfn peel(food: Option<Food>) -> Option<Peeled> {\n    match food {\n        Some(food) => Some(Peeled(food)),\n        None       => None,\n    }\n}\n\n// 切食物。如果没有食物，就返回 `None`。否则返回切好的食物。\nfn chop(peeled: Option<Peeled>) -> Option<Chopped> {\n    match peeled {\n        Some(Peeled(food)) => Some(Chopped(food)),\n        None               => None,\n    }\n}\n\n// 烹饪食物。这里，我们使用 `map()` 来替代 `match` 以处理各种情况。\nfn cook(chopped: Option<Chopped>) -> Option<Cooked> {\n    chopped.map(|Chopped(food)| Cooked(food))\n}\n\n// 这个函数会完成削皮切块烹饪一条龙。我们把 `map()` 串起来，以简化代码。\nfn process(food: Option<Food>) -> Option<Cooked> {\n    food.map(|f| Peeled(f))\n        .map(|Peeled(f)| Chopped(f))\n        .map(|Chopped(f)| Cooked(f))\n}\n\n// 在尝试吃食物之前确认食物是否存在是非常重要的！\nfn eat(food: Option<Cooked>) {\n    match food {\n        Some(food) => println!("Mmm. I love {:?}", food),\n        None       => println!("Oh no! It wasn\'t edible."),\n    }\n}\n\nfn main() {\n    let apple = Some(Food::Apple);\n    let carrot = Some(Food::Carrot);\n    let potato = None;\n\n    let cooked_apple = cook(chop(peel(apple)));\n    let cooked_carrot = cook(chop(peel(carrot)));\n\n    // 现在让我们试试看起来更简单的 `process()`。\n    let cooked_potato = process(potato);\n\n    eat(cooked_apple);\n    eat(cooked_carrot);\n    eat(cooked_potato);\n}\n')])])]),n("h3",{attrs:{id:"参见："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[o._v("#")]),o._v(" 参见：")]),o._v(" "),n("p",[n("RouterLink",{attrs:{to:"/fn/closures.html"}},[o._v("闭包")]),o._v(", "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/option/enum.Option.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[o._v("Option")]),n("OutboundLink")],1),o._v(", 和 "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/option/enum.Option.html#method.map",target:"_blank",rel:"noopener noreferrer"}},[n("code",[o._v("Option::map()")]),n("OutboundLink")],1)],1)])}),[],!1,null,null,null);e.default=p.exports}}]);