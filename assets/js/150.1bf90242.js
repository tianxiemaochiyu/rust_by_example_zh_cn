(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{627:function(e,t,n){"use strict";n.r(t);var s=n(4),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"散列集-hashset"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#散列集-hashset"}},[e._v("#")]),e._v(" 散列集 HashSet")]),e._v(" "),n("p",[e._v("请把 "),n("code",[e._v("HashSet")]),e._v(" 当成这样一个 "),n("code",[e._v("HashMap")]),e._v("：我们只关心其中的键而非值（"),n("code",[e._v("HashSet<T>")]),e._v("\n实际上只是对 "),n("code",[e._v("HashMap<T, ()>")]),e._v(" 的封装）。")]),e._v(" "),n("p",[e._v("你可能会问：“这有什么意义呢？我完全可以将键存储到一个 "),n("code",[e._v("Vec")]),e._v(" 中呀。”")]),e._v(" "),n("p",[n("code",[e._v("HashSet")]),e._v(" 的独特之处在于，它保证了不会出现重复的元素。这是任何 set 集合类型（set\ncollection）遵循的规定。"),n("code",[e._v("HashSet")]),e._v(" 只是它的一个实现。（参见："),n("a",{attrs:{href:"http://doc.rust-lang.org/std/collections/struct.BTreeSet.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("BTreeSet")]),n("OutboundLink")],1),e._v("）")]),e._v(" "),n("p",[e._v("如果插入的值已经存在于 "),n("code",[e._v("HashSet")]),e._v(" 中（也就是，新值等于已存在的值，并且拥有相同\n的散列值），那么新值将会替换旧的值。")]),e._v(" "),n("p",[e._v("如果你不想要一样东西出现多于一次，或者你要判断一样东西是不是已经存在，这种做法\n就很有用了。")]),e._v(" "),n("p",[e._v("不过集合（set）可以做更多的事。")]),e._v(" "),n("p",[e._v("集合（set）拥有 4 种基本操作（下面的调用全部都返回一个迭代器）：")]),e._v(" "),n("ul",[n("li",[n("p",[n("code",[e._v("union")]),e._v("（并集）：获得两个集合中的所有元素（不含重复值）。")])]),e._v(" "),n("li",[n("p",[n("code",[e._v("difference")]),e._v("（差集）：获取属于第一个集合而不属于第二集合的所有元素。")])]),e._v(" "),n("li",[n("p",[n("code",[e._v("intersection")]),e._v("（交集）：获取同时属于两个集合的所有元素。")])]),e._v(" "),n("li",[n("p",[n("code",[e._v("symmetric_difference")]),e._v("（对称差）：获取所有只属于其中一个集合，而不同时属于\n两个集合的所有元素。")])])]),e._v(" "),n("p",[e._v("在下面的例子中尝试使用这些操作。")]),e._v(" "),n("div",{staticClass:"language-rust,editable,ignore,mdbook-runnable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('use std::collections::HashSet;\n\nfn main() {\n    let mut a: HashSet<i32> = vec!(1i32, 2, 3).into_iter().collect();\n    let mut b: HashSet<i32> = vec!(2i32, 3, 4).into_iter().collect();\n\n    assert!(a.insert(4));\n    assert!(a.contains(&4));\n\n    // 如果值已经存在，那么 `HashSet::insert()` 返回 false。\n    assert!(b.insert(4), "Value 4 is already in set B!");\n    // 改正 ^ 将此行注释掉。\n\n    b.insert(5);\n\n    // 若一个集合（collection）的元素类型实现了 `Debug`，那么该集合也就实现了 `Debug`。\n    // 这通常将元素打印成这样的格式 `[elem1, elem2, ...]\n    println!("A: {:?}", a);\n    println!("B: {:?}", b);\n\n    // 乱序打印 [1, 2, 3, 4, 5]。\n    println!("Union: {:?}", a.union(&b).collect::<Vec<&i32>>());\n\n    // 这将会打印出 [1]\n    println!("Difference: {:?}", a.difference(&b).collect::<Vec<&i32>>());\n\n    // 乱序打印 [2, 3, 4]。\n    println!("Intersection: {:?}", a.intersection(&b).collect::<Vec<&i32>>());\n\n    // 打印 [1, 5]\n    println!("Symmetric Difference: {:?}",\n             a.symmetric_difference(&b).collect::<Vec<&i32>>());\n}\n')])])]),n("p",[e._v("（例子改编自"),n("a",{attrs:{href:"http://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档"),n("OutboundLink")],1),e._v("。）")])])}),[],!1,null,null,null);t.default=r.exports}}]);