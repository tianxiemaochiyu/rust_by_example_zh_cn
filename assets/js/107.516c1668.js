(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{588:function(n,e,t){"use strict";t.r(e);var a=t(4),l=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"使用-macro-rules-来创建宏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-macro-rules-来创建宏"}},[n._v("#")]),n._v(" 使用 "),t("code",[n._v("macro_rules!")]),n._v(" 来创建宏")]),n._v(" "),t("p",[n._v("Rust 提供了一个强大的宏系统，可进行元编程（metaprogramming）。你已经在前面的\n章节中看到，宏看起来和函数很像，只不过名称末尾有一个感叹号 "),t("code",[n._v("!")]),n._v(" 。宏并不产\n生函数调用，而是展开成源码，并和程序的其余部分一起被编译。Rust 又有一点和 C\n以及其他语言都不同，那就是 Rust 的宏会展开为抽象语法树（AST，abstract syntax\ntree），而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权\n错误。")]),n._v(" "),t("p",[n._v("宏是通过 "),t("code",[n._v("macro_rules!")]),n._v(" 宏来创建的。")]),n._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 这是一个简单的宏，名为 `say_hello`。\nmacro_rules! say_hello {\n    // `()` 表示此宏不接受任何参数。\n    () => (\n        // 此宏将会展开成这个代码块里面的内容。\n        println!("Hello!");\n    )\n}\n\nfn main() {\n    // 这个调用将会展开成 `println("Hello");`!\n    say_hello!()\n}\n')])])]),t("p",[n._v("为什么宏是有用的？")]),n._v(" "),t("ol",[t("li",[n._v("不写重复代码（DRY，Don't repeat yourself.）。很多时候你需要在一些地方针对不同\n的类型实现类似的功能，这时常常可以使用宏来避免重复代码（稍后详述）。")]),n._v(" "),t("li",[n._v("领域专用语言（DSL，domain-specific language）。宏允许你为特定的目的创造特定的\n语法（稍后详述）。")]),n._v(" "),t("li",[n._v("可变接口（variadic interface）。有时你需要能够接受不定数目参数的接口，比如\n"),t("code",[n._v("println!")]),n._v("，根据格式化字符串的不同，它需要接受任意多的参数（稍后详述）。")])])])}),[],!1,null,null,null);e.default=l.exports}}]);