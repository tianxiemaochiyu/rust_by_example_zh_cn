(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{519:function(r,t,e){"use strict";e.r(t);var n=e(4),o=Object(n.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"把错误-装箱"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#把错误-装箱"}},[r._v("#")]),r._v(" 把错误 “装箱”")]),r._v(" "),e("p",[r._v("如果又想写简单的代码，又想保存原始错误信息，一个方法是把它们"),e("a",{attrs:{href:"https://doc.rust-lang.org/std/boxed/struct.Box.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("装箱"),e("OutboundLink")],1),r._v("（"),e("code",[r._v("Box")]),r._v("）。这\n样做的坏处就是，被包装的错误类型只能在运行时了解，而不能被"),e("a",{attrs:{href:"https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch",target:"_blank",rel:"noopener noreferrer"}},[r._v("静态地\n判别"),e("OutboundLink")],1),r._v("。")]),r._v(" "),e("p",[r._v("对任何实现了 "),e("code",[r._v("Error")]),r._v(" trait 的类型，标准库的 "),e("code",[r._v("Box")]),r._v(" 通过 "),e("a",{attrs:{href:"https://doc.rust-lang.org/std/convert/trait.From.html",target:"_blank",rel:"noopener noreferrer"}},[e("code",[r._v("From")]),e("OutboundLink")],1),r._v(" 为它们提供了\n到 "),e("code",[r._v("Box<Error>")]),r._v(" 的转换。")]),r._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('use std::error;\nuse std::fmt;\n\n// 为 `Box<error::Error>` 取别名。\ntype Result<T> = std::result::Result<T, Box<error::Error>>;\n\n#[derive(Debug, Clone)]\nstruct EmptyVec;\n\nimpl fmt::Display for EmptyVec {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, "invalid first item to double")\n    }\n}\n\nimpl error::Error for EmptyVec {\n    fn description(&self) -> &str {\n        "invalid first item to double"\n    }\n\n    fn cause(&self) -> Option<&error::Error> {\n        // 泛型错误。没有记录其内部原因。\n        None\n    }\n}\n\nfn double_first(vec: Vec<&str>) -> Result<i32> {\n    vec.first()\n       .ok_or_else(|| EmptyVec.into())  // 装箱\n       .and_then(|s| {\n            s.parse::<i32>()\n                .map_err(|e| e.into())  // 装箱\n                .map(|i| 2 * i)\n        })\n}\n\nfn print(result: Result<i32>) {\n    match result {\n        Ok(n)  => println!("The first doubled is {}", n),\n        Err(e) => println!("Error: {}", e),\n    }\n}\n\nfn main() {\n    let numbers = vec!["42", "93", "18"];\n    let empty = vec![];\n    let strings = vec!["tofu", "93", "18"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n')])])]),e("h3",{attrs:{id:"参见："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[r._v("#")]),r._v(" 参见：")]),r._v(" "),e("p",[e("a",{attrs:{href:"https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch",target:"_blank",rel:"noopener noreferrer"}},[r._v("动态调度"),e("OutboundLink")],1),r._v(" and "),e("a",{attrs:{href:"https://doc.rust-lang.org/std/error/trait.Error.html",target:"_blank",rel:"noopener noreferrer"}},[e("code",[r._v("Error")]),r._v(" trait"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=o.exports}}]);