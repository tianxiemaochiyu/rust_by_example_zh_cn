(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{526:function(e,t,n){"use strict";n.r(t);var r=n(4),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"结果-result"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结果-result"}},[e._v("#")]),e._v(" 结果 "),n("code",[e._v("Result")])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://doc.rust-lang.org/std/result/enum.Result.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("Result")]),n("OutboundLink")],1),e._v(" 是 "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/option/enum.Option.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("Option")]),n("OutboundLink")],1),e._v(" 类型的更丰富的版本，描述的是可能\n的"),n("strong",[e._v("错误")]),e._v("而不是可能的"),n("strong",[e._v("不存在")]),e._v("。")]),e._v(" "),n("p",[e._v("也就是说，"),n("code",[e._v("Result<T，E>")]),e._v(" 可以有两个结果的其中一个：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("Ok<T>")]),e._v("：找到 "),n("code",[e._v("T")]),e._v(" 元素")]),e._v(" "),n("li",[n("code",[e._v("Err<E>")]),e._v("：找到 "),n("code",[e._v("E")]),e._v(" 元素，"),n("code",[e._v("E")]),e._v(" 即表示错误的类型。")])]),e._v(" "),n("p",[e._v("按照约定，预期结果是 “Ok”，而意外结果是 “Err”。")]),e._v(" "),n("p",[n("code",[e._v("Result")]),e._v(" 有很多类似 "),n("code",[e._v("Option")]),e._v(" 的方法。例如 "),n("code",[e._v("unwrap()")]),e._v("，它要么举出元素\n"),n("code",[e._v("T")]),e._v("，要么就 "),n("code",[e._v("panic")]),e._v("。 对于事件的处理，"),n("code",[e._v("Result")]),e._v(" 和 "),n("code",[e._v("Option")]),e._v(" 有很多相同的组合算子。")]),e._v(" "),n("p",[e._v("在使用 Rust 时，你可能会遇到返回 "),n("code",[e._v("Result")]),e._v(" 类型的方法，例如 "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/primitive.str.html#method.parse",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("parse()")]),n("OutboundLink")],1),e._v("\n方法。它并不是总能把字符串解析成指定的类型，所以 "),n("code",[e._v("parse()")]),e._v(" 返回一个\n"),n("code",[e._v("Result")]),e._v(" 表示可能的失败。")]),e._v(" "),n("p",[e._v("我们来看看当 "),n("code",[e._v("parse()")]),e._v(" 字符串成功和失败时会发生什么：")]),e._v(" "),n("div",{staticClass:"language-rust,editable,ignore,mdbook-runnable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('fn multiply(first_number_str: &str, second_number_str: &str) -> i32 {\n    // 我们试着用 `unwrap()` 把数字放出来。它会咬我们一口吗？\n    let first_number = first_number_str.parse::<i32>().unwrap();\n    let second_number = second_number_str.parse::<i32>().unwrap();\n    first_number * second_number\n}\n\nfn main() {\n    let twenty = multiply("10", "2");\n    println!("double is {}", twenty);\n\n    let tt = multiply("t", "2");\n    println!("double is {}", tt);\n}\n')])])]),n("p",[e._v("在失败的情况下，"),n("code",[e._v("parse()")]),e._v(" 产生一个错误，留给 "),n("code",[e._v("unwrap()")]),e._v(" 来解包并产生 "),n("code",[e._v("panic")]),e._v("。另\n外，"),n("code",[e._v("panic")]),e._v(" 会退出我们的程序，并提供一个让人很不爽的错误消息。")]),e._v(" "),n("p",[e._v("为了改善错误消息的质量，我们应该更具体地了解返回类型并考虑显式地处理错误。")])])}),[],!1,null,null,null);t.default=_.exports}}]);