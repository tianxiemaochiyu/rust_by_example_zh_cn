(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{586:function(t,e,a){"use strict";a.r(e);var n=a(4),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"dsl（领域专用语言）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dsl（领域专用语言）"}},[t._v("#")]),t._v(" DSL（领域专用语言）")]),t._v(" "),a("p",[t._v("DSL 是 Rust 的宏中集成的微型 “语言”。这种语言是完全合法的，因为宏系统会把它转换\n成普通的 Rust 语法树，它只不过看起来像是另一种语言而已。这就允许你为一些特定功能\n创造一套简洁直观的语法（当然是有限制的）。")]),t._v(" "),a("p",[t._v("比如说我想要定义一套小的计算器 API，可以传给它表达式，它会把结果打印到控制台上。")]),t._v(" "),a("div",{staticClass:"language-rust,editable extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('macro_rules! calculate {\n    (eval $e:expr) => {{\n        {\n            let val: usize = $e; // 强制类型为整型\n            println!("{} = {}", stringify!{$e}, val);\n        }\n    }};\n}\n\nfn main() {\n    calculate! {\n        eval 1 + 2 // 看到了吧，`eval` 可并不是 Rust 的关键字！\n    }\n\n    calculate! {\n        eval (1 + 2) * (3 / 4)\n    }\n}\n')])])]),a("p",[t._v("输出:")]),t._v(" "),a("div",{staticClass:"language-txt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1 + 2 = 3\n(1 + 2) * (3 / 4) = 0\n")])])]),a("p",[t._v("这个例子非常简单，但是已经有很多利用宏开发的复杂接口了，比如\n"),a("a",{attrs:{href:"https://crates.io/crates/lazy_static",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("lazy_static")]),a("OutboundLink")],1),t._v(" 和\n"),a("a",{attrs:{href:"https://crates.io/crates/clap",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("clap")]),a("OutboundLink")],1),t._v("。")])])}),[],!1,null,null,null);e.default=r.exports}}]);