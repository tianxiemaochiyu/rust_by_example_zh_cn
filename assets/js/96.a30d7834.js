(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{576:function(t,a,n){"use strict";n.r(a);var r=n(4),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"虚类型参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#虚类型参数"}},[t._v("#")]),t._v(" 虚类型参数")]),t._v(" "),n("p",[t._v("虚类型（phantom type）参数是一种在运行时不出现，而在（且仅在）编译时进行静态检查\n的类型参数。")]),t._v(" "),n("p",[t._v("可以用额外的泛型类型参数指定数据类型，这类型可以充当标记，也可以供编译时类型检查\n使用。这些额外的参数没有存储值，也没有运行时行为。")]),t._v(" "),n("p",[t._v("在下面例子中，我们使用 "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/marker/struct.PhantomData.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::marker::PhantomData"),n("OutboundLink")],1),t._v(" 作为虚类型参数的类型，创建\n包含不同数据类型的元组。")]),t._v(" "),n("div",{staticClass:"language-rust,editable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("use std::marker::PhantomData;\n\n// 这个虚元组结构体对 `A` 是泛型的，并且带有隐藏参数 `B`。\n#[derive(PartialEq)] // 允许这种类型进行相等测试（equality test）。\nstruct PhantomTuple<A, B>(A,PhantomData<B>);\n\n// 这个虚类型结构体对 `A` 是泛型的，并且带有隐藏参数 `B`。\n#[derive(PartialEq)] // 允许这种类型进行相等测试。\nstruct PhantomStruct<A, B> { first: A, phantom: PhantomData<B> }\n\n// 注意：对于泛型 `A` 会分配存储空间，但 `B` 不会。\n//       因此，`B` 不能参与运算。\n\nfn main() {\n    // 这里的 `f32` 和 `f64` 是隐藏参数。\n    // 被指定为 `<char, f32>` 的 `PhantomTuple` 类型。\n    let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);\n    // 被指定为 `<char, f64>` `PhantomTuple` 类型。\n    let _tuple2: PhantomTuple<char, f64> = PhantomTuple('Q', PhantomData);\n\n    // 被指定为 `<char, f32>` 的类型。\n    let _struct1: PhantomStruct<char, f32> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n    // 被指定为 `<char, f64>` 的类型。\n    let _struct2: PhantomStruct<char, f64> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n    \n    // 编译期错误！类型不匹配，所以这些值不能够比较：\n    //println!(\"_tuple1 == _tuple2 yields: {}\",\n    //          _tuple1 == _tuple2);\n    \n    // 编译期错误！类型不匹配，所以这些值不能够比较：\n    //println!(\"_struct1 == _struct2 yields: {}\",\n    //          _struct1 == _struct2);\n}\n")])])]),n("h3",{attrs:{id:"参见："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),n("p",[n("RouterLink",{attrs:{to:"/trait/derive.html"}},[t._v("Derive")]),t._v(", "),n("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[t._v("结构体")]),t._v(", 和 "),n("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[t._v("元组结构体")])],1)])}),[],!1,null,null,null);a.default=e.exports}}]);