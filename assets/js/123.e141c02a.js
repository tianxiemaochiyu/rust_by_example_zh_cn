(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{602:function(e,t,_){"use strict";_.r(t);var v=_(4),n=Object(v.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"原生类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原生类型"}},[e._v("#")]),e._v(" 原生类型")]),e._v(" "),_("p",[e._v("Rust 提供了多种原生类型(primitive)，包括：")]),e._v(" "),_("h2",{attrs:{id:"标量类型（scalar-type）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标量类型（scalar-type）"}},[e._v("#")]),e._v(" 标量类型（scalar type）")]),e._v(" "),_("ul",[_("li",[e._v("有符号整型（signed integers）："),_("code",[e._v("i8")]),e._v("、"),_("code",[e._v("i16")]),e._v("、"),_("code",[e._v("i32")]),e._v("、"),_("code",[e._v("i64")]),e._v(" 和 "),_("code",[e._v("isize")]),e._v("（指针宽度）")]),e._v(" "),_("li",[e._v("无符号整型（unsigned integers）： "),_("code",[e._v("u8")]),e._v("、"),_("code",[e._v("u16")]),e._v("、"),_("code",[e._v("u32")]),e._v("、"),_("code",[e._v("u64")]),e._v(" 和 "),_("code",[e._v("usize")]),e._v("（指针宽\n度）")]),e._v(" "),_("li",[e._v("浮点类型（floating point）： "),_("code",[e._v("f32")]),e._v("、"),_("code",[e._v("f64")])]),e._v(" "),_("li",[_("code",[e._v("char")]),e._v("（字符）：单个 Unicode 字符，如 "),_("code",[e._v("'a'")]),e._v("，"),_("code",[e._v("'α'")]),e._v(" 和 "),_("code",[e._v("'∞'")]),e._v("（每个都是 4 字节）")]),e._v(" "),_("li",[_("code",[e._v("bool")]),e._v("（布尔型）：只能是 "),_("code",[e._v("true")]),e._v(" 或 "),_("code",[e._v("false")])]),e._v(" "),_("li",[e._v("单元类型（unit type）："),_("code",[e._v("()")]),e._v("。其唯一可能的值就是 "),_("code",[e._v("()")]),e._v(" 这个空元组")])]),e._v(" "),_("p",[e._v("尽管单元类型的值是个元组，它却并不被认为是复合类型，因为并不包含多个值。")]),e._v(" "),_("h2",{attrs:{id:"复合类型（compound-type）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#复合类型（compound-type）"}},[e._v("#")]),e._v(" 复合类型（compound type）")]),e._v(" "),_("ul",[_("li",[e._v("数组（array）：如 "),_("code",[e._v("[1, 2, 3]")])]),e._v(" "),_("li",[e._v("元组（tuple）：如 "),_("code",[e._v("(1, true)")])])]),e._v(" "),_("p",[e._v("变量都能够显式地给出"),_("strong",[e._v("类型说明")]),e._v("（type annotation）。数字还可以通过"),_("strong",[e._v("后缀")]),e._v("\n（suffix）或"),_("strong",[e._v("默认方式")]),e._v("来声明类型。整型默认为 "),_("code",[e._v("i32")]),e._v(" 类型，浮点型默认为 "),_("code",[e._v("f64")]),e._v("\n类型。注意 Rust 还可以根据上下文来推断（infer）类型（译注：比如一个未声明类型整\n数和 "),_("code",[e._v("i64")]),e._v(" 的整数相加，则该整数会自动推断为 "),_("code",[e._v("i64")]),e._v(" 类型。仅当根据环境无法推断时\n，才按默认方式取整型数值为 "),_("code",[e._v("i32")]),e._v("，浮点数值为 "),_("code",[e._v("f64")]),e._v("）。")]),e._v(" "),_("div",{staticClass:"language-rust,editable,ignore,mdbook-runnable extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("fn main() {\n    // 变量可以给出类型说明。\n    let logical: bool = true;\n\n    let a_float: f64 = 1.0;  // 常规说明\n    let an_integer   = 5i32; // 后缀说明\n\n    // 否则会按默认方式决定类型。\n    let default_float   = 3.0; // `f64`\n    let default_integer = 7;   // `i32`\n    \n    // 类型也可根据上下文自动推断。\n    let mut inferred_type = 12; // 根据下一行的赋值推断为 i64 类型\n    inferred_type = 4294967296i64;\n    \n    // 可变的（mutable）变量，其值可以改变。\n    let mut mutable = 12; // Mutable `i32`\n    mutable = 21;\n    \n    // 报错！变量的类型并不能改变。\n    mutable = true;\n    \n    // 但可以用掩蔽（shadow）来覆盖前面的变量。\n    let mutable = true;\n}\n")])])]),_("h3",{attrs:{id:"参见："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[e._v("#")]),e._v(" 参见：")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://doc.rust-lang.org/std/",target:"_blank",rel:"noopener noreferrer"}},[_("code",[e._v("std")]),e._v(" 库"),_("OutboundLink")],1),e._v("、"),_("RouterLink",{attrs:{to:"/variable_bindings/mut.html"}},[_("code",[e._v("mut")])]),e._v("、"),_("RouterLink",{attrs:{to:"/types/inference.html"}},[e._v("类型推断")]),e._v(" 和"),_("a",{attrs:{href:"shadowing"}},[e._v("变量掩蔽")]),e._v("。")],1)])}),[],!1,null,null,null);t.default=n.exports}}]);