(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{589:function(s,n,t){"use strict";t.r(n);var e=t(4),a=Object(e.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"dry-不写重复代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dry-不写重复代码"}},[s._v("#")]),s._v(" DRY (不写重复代码)")]),s._v(" "),t("p",[s._v("通过提取函数或测试集的公共部分，宏可以让你写出 DRY 的代码（DRY 是 Don't Repeat\nYourself 的缩写，意思为 “不要写重复代码”）。这里给出一个例子，对 "),t("code",[s._v("Vec<T>")]),s._v(" 实现\n并测试了关于 "),t("code",[s._v("+=")]),s._v("、"),t("code",[s._v("*=")]),s._v(" 和 "),t("code",[s._v("-=")]),s._v(" 等运算符。")]),s._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('use std::ops::{Add, Mul, Sub};\n\nmacro_rules! assert_equal_len {\n    // `tt`（token tree，标记树）指示符表示运算符和标记。\n    ($a:ident, $b: ident, $func:ident, $op:tt) => (\n        assert!($a.len() == $b.len(),\n                "{:?}: dimension mismatch: {:?} {:?} {:?}",\n                stringify!($func),\n                ($a.len(),),\n                stringify!($op),\n                ($b.len(),));\n    )\n}\n\nmacro_rules! op {\n    ($func:ident, $bound:ident, $op:tt, $method:ident) => (\n        fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut Vec<T>, ys: &Vec<T>) {\n            assert_equal_len!(xs, ys, $func, $op);\n\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n                *x = $bound::$method(*x, *y);\n                // *x = x.$method(*y);\n            }\n        }\n    )\n}\n\n// 实现 `add_assign`、`mul_assign` 和 `sub_assign` 等函数。\nop!(add_assign, Add, +=, add);\nop!(mul_assign, Mul, *=, mul);\nop!(sub_assign, Sub, -=, sub);\n\nmod test {\n    use std::iter;\n    macro_rules! test {\n        ($func: ident, $x:expr, $y:expr, $z:expr) => {\n            #[test]\n            fn $func() {\n                for size in 0usize..10 {\n                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();\n                    let y: Vec<_> = iter::repeat($y).take(size).collect();\n                    let z: Vec<_> = iter::repeat($z).take(size).collect();\n\n                    super::$func(&mut x, &y);\n\n                    assert_eq!(x, z);\n                }\n            }\n        }\n    }\n\n    // 测试 `add_assign`、`mul_assign` 和 `sub_assign`\n    test!(add_assign, 1u32, 2u32, 3u32);\n    test!(mul_assign, 2u32, 3u32, 6u32);\n    test!(sub_assign, 3u32, 2u32, 1u32);\n}\n\n')])])]),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("$ rustc --test dry.rs "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" ./dry\nrunning "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" tests\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("test")]),s._v(" test::mul_assign "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(". ok\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("test")]),s._v(" test::add_assign "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(". ok\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("test")]),s._v(" test::sub_assign "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(". ok\n\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("test")]),s._v(" result: ok. "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" passed"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" failed"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" ignored"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" measured\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);