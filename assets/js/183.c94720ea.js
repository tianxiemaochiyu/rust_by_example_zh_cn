(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{662:function(n,t,e){"use strict";e.r(t);var r=e(4),o=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"iterators"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iterators"}},[n._v("#")]),n._v(" Iterators")]),n._v(" "),e("p",[e("code",[n._v("Iterator")]),n._v(" trait 用来对集合（collection）类型（比如数组）实现迭代器。")]),n._v(" "),e("p",[n._v("这个 trait 只需定义一个返回 "),e("code",[n._v("next")]),n._v("（下一个）元素的方法，这可手动在 "),e("code",[n._v("impl")]),n._v(" 代码块\n中定义，或者自动定义（比如在数组或区间中）。")]),n._v(" "),e("p",[n._v("为方便起见，"),e("code",[n._v("for")]),n._v(" 结构会使用 "),e("a",{attrs:{href:"https://doc.rust-lang.org/std/iter/trait.IntoIterator.html",target:"_blank",rel:"noopener noreferrer"}},[e("code",[n._v(".into_iterator()")]),e("OutboundLink")],1),n._v(" 方法将一些集合类型\n转换为迭代器。")]),n._v(" "),e("p",[n._v("下面例子展示了如何使用 "),e("code",[n._v("Iterator")]),n._v(" trait 的方法，更多可用的方法可以看"),e("a",{attrs:{href:"http://doc.rust-lang.org/core/iter/trait.Iterator.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("这里"),e("OutboundLink")],1),n._v("。")]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('struct Fibonacci {\n    curr: u32,\n    next: u32,\n}\n\n// 为 `Fibonacci`（斐波那契）实现 `Iterator`。\n// `Iterator` trait 只需定义一个能返回 `next`（下一个）元素的方法。\nimpl Iterator for Fibonacci {\n    type Item = u32;\n    \n    // 我们在这里使用 `.curr` 和 `.next` 来定义数列（sequence）。\n    // 返回类型为 `Option<T>`：\n    //     * 当 `Iterator` 结束时，返回 `None`。\n    //     * 其他情况，返回被 `Some` 包裹（wrap）的下一个值。\n    fn next(&mut self) -> Option<u32> {\n        let new_next = self.curr + self.next;\n\n        self.curr = self.next;\n        self.next = new_next;\n\n        // 既然斐波那契数列不存在终点，那么 `Iterator` 将不可能\n        // 返回 `None`，而总是返回 `Some`。\n        Some(self.curr)\n    }\n}\n\n// 返回一个斐波那契数列生成器\nfn fibonacci() -> Fibonacci {\n    Fibonacci { curr: 1, next: 1 }\n}\n\nfn main() {\n    // `0..3` 是一个 `Iterator`，会产生：0、1 和 2。\n    let mut sequence = 0..3;\n\n    println!("Four consecutive `next` calls on 0..3");\n    println!("> {:?}", sequence.next());\n    println!("> {:?}", sequence.next());\n    println!("> {:?}", sequence.next());\n    println!("> {:?}", sequence.next());\n\n    // `for` 遍历 `Iterator` 直到返回 `None`，\n    // 并且每个 `Some` 值都被解包（unwrap），然后绑定给一个变量（这里是 `i`）。       println!("Iterate through 0..3 using `for`");\n    for i in 0..3 {\n        println!("> {}", i);\n    }\n\n    // `take(n)` 方法提取 `Iterator` 的前 `n` 项。\n    println!("The first four terms of the Fibonacci sequence are: ");\n    for i in fibonacci().take(4) {\n        println!("> {}", i);\n    }\n\n    // `skip(n)` 方法移除前 `n` 项，从而缩短了 `Iterator` 。\n    println!("The next four terms of the Fibonacci sequence are: ");\n    for i in fibonacci().skip(4).take(4) {\n        println!("> {}", i);\n    }\n\n    let array = [1u32, 3, 3, 7];\n\n    // `iter` 方法对数组/slice 产生一个 `Iterator`。\n    println!("Iterate the following array {:?}", &array);\n    for i in array.iter() {\n        println!("> {}", i);\n    }\n}\n')])])])])}),[],!1,null,null,null);t.default=o.exports}}]);