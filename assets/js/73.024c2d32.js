(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{553:function(n,t,e){"use strict";e.r(t);var s=e(4),r=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[n._v("#")]),n._v(" 闭包")]),n._v(" "),e("p",[n._v("Rust 中的闭包（closure），也叫做 lambda 表达式或者 lambda，是一类能够捕获周围\n作用域中变量的函数。例如，一个可以捕获 x 变量的闭包如下：")]),n._v(" "),e("div",{staticClass:"language-Rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[n._v("|")]),n._v("val"),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v("|")]),n._v(" val "),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v("+")]),n._v(" x\n")])])]),e("p",[n._v("它们的语法和能力使它们在临时（on the fly）使用时相当方便。调用一个闭包和调用一个\n函数完全相同，不过调用闭包时，输入和返回类型两者都"),e("strong",[n._v("可以")]),n._v("自动推导，而输入变量\n名"),e("strong",[n._v("必须")]),n._v("指明。")]),n._v(" "),e("p",[n._v("其他的特点包括：")]),n._v(" "),e("ul",[e("li",[n._v("声明时使用 "),e("code",[n._v("||")]),n._v(" 替代 "),e("code",[n._v("()")]),n._v(" 将输入参数括起来。")]),n._v(" "),e("li",[n._v("函数体定界符（"),e("code",[n._v("{}")]),n._v("）对于单个表达式是可选的，其他情况必须加上。")]),n._v(" "),e("li",[n._v("有能力捕获外部环境的变量。")])]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('fn main() {\n    // 通过闭包和函数分别实现自增。\n    // 译注：下面这行是使用函数的实现\n    fn  function            (i: i32) -> i32 { i + 1 }\n\n    // 闭包是匿名的，这里我们将它们绑定到引用。\n    // 类型标注和函数的一样，不过类型标注和使用 `{}` 来围住函数体都是可选的。\n    // 这些匿名函数（nameless function）被赋值给合适地命名的变量。\n    let closure_annotated = |i: i32| -> i32 { i + 1 };\n    let closure_inferred  = |i     |          i + 1  ;\n    \n    // 译注：将闭包绑定到引用的说法可能不准。\n    // 据[语言参考](https://doc.rust-lang.org/beta/reference/types.html#closure-types)\n    // 闭包表达式产生的类型就是 “闭包类型”，不属于引用类型，而且确实无法对上面两个\n    // `closure_xxx` 变量解引用。\n    \n    let i = 1;\n    // 调用函数和闭包。\n    println!("function: {}", function(i));\n    println!("closure_annotated: {}", closure_annotated(i));\n    println!("closure_inferred: {}", closure_inferred(i));\n\n    // 没有参数的闭包，返回一个 `i32` 类型。\n    // 返回类型是自动推导的。\n    let one = || 1;\n    println!("closure returning one: {}", one());\n}\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);