(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{554:function(n,t,e){"use strict";e.r(t);var o=e(4),r=Object(o.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"捕获"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#捕获"}},[n._v("#")]),n._v(" 捕获")]),n._v(" "),e("p",[n._v("闭包天生就是灵活的，它会自动满足函数功能的要求，使得闭包不需要类型说明就可以\n工作。这允许变量捕获（capture）灵活地适应使用场合，既可移动（move）又可\n借用（borrow）变量。闭包可以通过以下手段捕获变量：")]),n._v(" "),e("ul",[e("li",[n._v("通过引用："),e("code",[n._v("&T")])]),n._v(" "),e("li",[n._v("通过可变引用："),e("code",[n._v("&mut T")])]),n._v(" "),e("li",[n._v("通过值："),e("code",[n._v("T")])])]),n._v(" "),e("p",[n._v("闭包更倾向于通过引用来捕获变量，并且只在被要求时才使用其他手段。")]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('fn main() {\n    use std::mem;\n    \n    let color = "green";\n\n    // 这个闭包打印 `color`。它会立即借用（通过引用，`&`）`color` 并将该借用和\n    // 闭包本身存储到 `print` 变量中。`color` 会一直保持被借用状态直到\n    // `print` 离开作用域。\n    // `println!` 只需传引用就能使用，而这个闭包捕获的也是变量的引用，因此无需\n    // 进一步处理就可以使用 `println!`。\n    let print = || println!("`color`: {}", color);\n\n    // 调用闭包，闭包又借用 `color`。\n    print();\n    print();\n\n    let mut count = 0;\n\n    // 这个闭包使 `count` 值增加。要做到这点，它需要得到 `&mut count` 或者\n    // `count` 本身，但 `&mut count` 的要求没那么严格，所以我们采取这种方式。\n    // 该闭包立即借用 `count`。\n    //\n    // `inc` 前面需要加上 `mut`，因为闭包里存储着一个 `&mut` 变量。调用闭包时，\n    // 该变量的变化就意味着闭包内部发生了变化。因此闭包需要是可变的。\n    let mut inc = || {\n        count += 1;\n        println!("`count`: {}", count);\n    };\n\n    // 调用闭包。\n    inc();\n    inc();\n\n    //let reborrow = &mut count;\n    // ^ 试一试：将此行注释去掉。\n    \n    // 不可复制类型（non-copy type）。\n    let movable = Box::new(3);\n\n    // `mem::drop` 要求 `T` 类型本身，所以闭包将会捕获变量的值。这种情况下，\n    // 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动\n    // （move）到闭包中，因而 `movable` 变量在这里立即移动到了闭包中。\n    let consume = || {\n        println!("`movable`: {:?}", movable);\n        mem::drop(movable);\n    };\n\n    // `consume` 消耗了该变量，所以该闭包只能调用一次。\n    consume();\n    //consume();\n    // ^ 试一试：将此行注释去掉。\n}\n')])])]),e("p",[n._v("在竖线 "),e("code",[n._v("|")]),n._v(" 之前使用 "),e("code",[n._v("move")]),n._v(" 会强制闭包取得被捕获变量的所有权：")]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('fn main() {\n    // `Vec` 在语义上是不可复制的。\n    let haystack = vec![1, 2, 3];\n\n    let contains = move |needle| haystack.contains(needle);\n\n    println!("{}", contains(&1));\n    println!("{}", contains(&4));\n\n    //println!("There\'re {} elements in vec", haystack.len());\n    // ^ 取消上面一行的注释将导致编译时错误，因为借用检查不允许在变量被移动走\n    // 之后继续使用它。\n    \n    // 在闭包的签名中删除 `move` 会导致闭包以不可变方式借用 `haystack`，因此之后\n    // `haystack` 仍然可用，取消上面的注释也不会导致错误。\n}\n')])])]),e("h3",{attrs:{id:"参见："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[n._v("#")]),n._v(" 参见：")]),n._v(" "),e("p",[e("RouterLink",{attrs:{to:"/std/box.html"}},[e("code",[n._v("Box")])]),n._v(" 和 "),e("a",{attrs:{href:"https://doc.rust-lang.org/std/mem/fn.drop.html",target:"_blank",rel:"noopener noreferrer"}},[e("code",[n._v("std::mem::drop")]),e("OutboundLink")],1)],1)])}),[],!1,null,null,null);t.default=r.exports}}]);