(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{605:function(n,o,_){"use strict";_.r(o);var e=_(4),i=Object(e.a)({},(function(){var n=this,o=n.$createElement,_=n._self._c||o;return _("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[_("h1",{attrs:{id:"借用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#借用"}},[n._v("#")]),n._v(" 借用")]),n._v(" "),_("p",[n._v("多数情况下，我们更希望能访问数据，同时不取得其所有权。为实现这点，Rust 使用\n了"),_("strong",[n._v("借用")]),n._v("（borrowing）机制。对象可以通过引用（"),_("code",[n._v("&T")]),n._v("）来传递，从而取代通过\n值（"),_("code",[n._v("T")]),n._v("）来传递。")]),n._v(" "),_("p",[n._v("编译器（通过借用检查）静态地保证了引用"),_("strong",[n._v("总是")]),n._v("指向有效的对象。也就是说，当存在\n引用指向一个对象时，该对象不能被销毁。")]),n._v(" "),_("div",{staticClass:"language-rust,editable,ignore,mdbook-runnable extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[n._v('// 此函数取得一个 box 的所有权并销毁它\nfn eat_box_i32(boxed_i32: Box<i32>) {\n    println!("Destroying box that contains {}", boxed_i32);\n}\n\n// 此函数借用了一个 i32 类型\nfn borrow_i32(borrowed_i32: &i32) {\n    println!("This int is: {}", borrowed_i32);\n}\n\nfn main() {\n    // 创建一个装箱的 i32 类型，以及一个存在栈中的 i32 类型。\n    let boxed_i32 = Box::new(5_i32);\n    let stacked_i32 = 6_i32;\n\n    // 借用了 box 的内容，但没有取得所有权，所以 box 的内容之后可以再次借用。\n    // 译注：请注意函数自身就是一个作用域，因此下面两个函数运行完成以后，\n    // 在函数中临时创建的引用也就不复存在了。\n    borrow_i32(&boxed_i32);\n    borrow_i32(&stacked_i32);\n\n    {\n        // 取得一个对 box 中数据的引用\n        let _ref_to_i32: &i32 = &boxed_i32;\n\n        // 报错！\n        // 当 `boxed_i32` 里面的值之后在作用域中被借用时，不能将其销毁。\n        eat_box_i32(boxed_i32);\n        // 改正 ^ 注释掉此行\n\n        // 在 `_ref_to_i32` 里面的值被销毁后，尝试借用 `_ref_to_i32`\n        //（译注：如果此处不借用，则在上一行的代码中，eat_box_i32(boxed_i32)可以将 `boxed_i32` 销毁。）\n        borrow_i32(_ref_to_i32);\n        // `_ref_to_i32` 离开作用域且不再被借用。\n    }\n\n    // `boxed_i32` 现在可以将所有权交给 `eat_i32` 并被销毁。\n    //（译注：能够销毁是因为已经不存在对 `boxed_i32` 的引用）\n    eat_box_i32(boxed_i32);\n}\n')])])])])}),[],!1,null,null,null);o.default=i.exports}}]);