(window.webpackJsonp=window.webpackJsonp||[]).push([[180],{660:function(n,e,r){"use strict";r.r(e);var t=r(4),i=Object(t.a)({},(function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"clone"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#clone"}},[n._v("#")]),n._v(" Clone")]),n._v(" "),r("p",[n._v("当处理资源时，默认的行为是在赋值或函数调用的同时将它们转移。但是我们有时候也需要\n把资源复制一份。")]),n._v(" "),r("p",[r("a",{attrs:{href:"https://doc.rust-lang.org/std/clone/trait.Clone.html",target:"_blank",rel:"noopener noreferrer"}},[r("code",[n._v("Clone")]),r("OutboundLink")],1),n._v(" trait 正好帮助我们完成这任务。通常，我们可以使用由 "),r("code",[n._v("Clone")]),n._v("\ntrait 定义的 "),r("code",[n._v(".clone()")]),n._v(" 方法。")]),n._v(" "),r("div",{staticClass:"language-rust,editable extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('// 不含资源的单元结构体\n#[derive(Debug, Clone, Copy)]\nstruct Nil;\n\n// 一个包含资源的结构体，它实现了 `Clone` trait\n#[derive(Clone, Debug)]\nstruct Pair(Box<i32>, Box<i32>);\n\nfn main() {\n    // 实例化 `Nil`\n    let nil = Nil;\n    // 复制 `Nil`，没有资源用于移动（move）\n    let copied_nil = nil;\n\n    // 两个 `Nil` 都可以独立使用\n    println!("original: {:?}", nil);\n    println!("copy: {:?}", copied_nil);\n\n    // 实例化 `Pair`\n    let pair = Pair(Box::new(1), Box::new(2));\n    println!("original: {:?}", pair);\n\n    // 将 `pair` 绑定到 `moved_pair`，移动（move）了资源\n    let moved_pair = pair;\n    println!("copy: {:?}", moved_pair);\n\n    // 报错！`pair` 已失去了它的资源。\n    //println!("original: {:?}", pair);\n    // 试一试 ^ 取消此行注释。\n\n    // 将 `moved_pair`（包括其资源）克隆到 `cloned_pair`。\n    let cloned_pair = moved_pair.clone();\n    // 使用 std::mem::drop 来销毁原始的 pair。\n    drop(moved_pair);\n\n    // 报错！`moved_pair` 已被销毁。\n    //println!("copy: {:?}", moved_pair);\n    // 试一试 ^ 将此行注释掉。\n\n    // 由 .clone() 得来的结果仍然可用！\n    println!("clone: {:?}", cloned_pair);\n}\n')])])])])}),[],!1,null,null,null);e.default=i.exports}}]);