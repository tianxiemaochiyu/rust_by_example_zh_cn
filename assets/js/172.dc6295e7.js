(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{651:function(n,t,e){"use strict";e.r(t);var s=e(4),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[n._v("#")]),n._v(" 线程")]),n._v(" "),e("p",[n._v("Rust 通过 "),e("code",[n._v("spawn")]),n._v(" 函数提供了创建本地操作系统（native OS）线程的机制，该函数的参数是一个通过值捕获变量的闭包（moving closure）。")]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('use std::thread;\n\nstatic NTHREADS: i32 = 10;\n\n// 这是主（`main`）线程\nfn main() {\n    // 提供一个 vector 来存放所创建的子线程（children）。\n    let mut children = vec![];\n\n    for i in 0..NTHREADS {\n        // 启动（spin up）另一个线程\n        children.push(thread::spawn(move || {\n            println!("this is thread number {}", i)\n        }));\n    }\n\n    for child in children {\n        // 等待线程结束。返回一个结果。\n        let _ = child.join();\n    }\n}\n')])])]),e("p",[n._v("这些线程由操作系统调度（schedule）。")])])}),[],!1,null,null,null);t.default=a.exports}}]);