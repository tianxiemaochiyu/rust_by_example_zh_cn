(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{637:function(n,e,t){"use strict";t.r(e);var s=t(4),r=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"通道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通道"}},[n._v("#")]),n._v(" 通道")]),n._v(" "),t("p",[n._v("Rust 为线程之间的通信提供了异步的通道（"),t("code",[n._v("channel")]),n._v("）。通道允许两个端点之间信息的\n单向流动："),t("code",[n._v("Sender")]),n._v("（发送端） 和 "),t("code",[n._v("Receiver")]),n._v("（接收端）。")]),n._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('use std::sync::mpsc::{Sender, Receiver};\nuse std::sync::mpsc;\nuse std::thread;\n\nstatic NTHREADS: i32 = 3;\n\nfn main() {\n    // 通道有两个端点：`Sender<T>` 和 `Receiver<T>`，其中 `T` 是要发送\n    // 的消息的类型（类型标注是可选的）\n    let (tx, rx): (Sender<i32>, Receiver<i32>) = mpsc::channel();\n\n    for id in 0..NTHREADS {\n        // sender 端可被复制\n        let thread_tx = tx.clone();\n\n        // 每个线程都将通过通道来发送它的 id\n        thread::spawn(move || {\n            // 被创建的线程取得 `thread_tx` 的所有权\n            // 每个线程都把消息放在通道的消息队列中\n            thread_tx.send(id).unwrap();\n\n            // 发送是一个非阻塞（non-blocking）操作，线程将在发送完消息后\n            // 会立即继续进行\n            println!("thread {} finished", id);\n        });\n    }\n\n    // 所有消息都在此处被收集\n    let mut ids = Vec::with_capacity(NTHREADS as usize);\n    for _ in 0..NTHREADS {\n        // `recv` 方法从通道中拿到一个消息\n        // 若无可用消息的话，`recv` 将阻止当前线程\n        ids.push(rx.recv());\n    }\n\n    // 显示消息被发送的次序\n    println!("{:?}", ids);\n}\n')])])])])}),[],!1,null,null,null);e.default=r.exports}}]);