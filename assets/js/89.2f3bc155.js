(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{566:function(t,e,n){"use strict";n.r(e);var a=n(4),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"约束"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#约束"}},[t._v("#")]),t._v(" 约束")]),t._v(" "),n("p",[t._v("在使用泛型时，类型参数常常必须使用 trait 作为"),n("strong",[t._v("约束")]),t._v("（bound）来明确规定\n类型应实现哪些功能。例如下面的例子用到了 "),n("code",[t._v("Display")]),t._v(" trait 来打印，所以它用\n"),n("code",[t._v("Display")]),t._v(" 来约束 "),n("code",[t._v("T")]),t._v("，也就是说 "),n("code",[t._v("T")]),t._v(" "),n("strong",[t._v("必须")]),t._v("实现 "),n("code",[t._v("Display")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 定义一个函数 `printer`，接受一个类型为泛型 `T` 的参数，\n// 其中 `T` 必须实现 `Display` trait。\nfn printer<T: Display>(t: T) {\n    println!("{}", t);\n}\n')])])]),n("p",[t._v("约束把泛型类型限制为符合约束的类型。请看：")]),t._v(" "),n("div",{staticClass:"language-rust,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("struct S<T: Display>(T);\n\n// 报错！`Vec<T>` 未实现 `Display`。此次泛型具体化失败。\nlet s = S(vec![1]);\n")])])]),n("p",[t._v("约束的另一个作用是泛型的实例可以访问作为约束的 trait 的方法。例如：")]),t._v(" "),n("div",{staticClass:"language-rust,editalbe extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 这个 trait 用来实现打印标记：`{:?}`。\nuse std::fmt::Debug;\n\ntrait HasArea {\n    fn area(&self) -> f64;\n}\n\nimpl HasArea for Rectangle {\n    fn area(&self) -> f64 { self.length * self.height }\n}\n\n#[derive(Debug)]\nstruct Rectangle { length: f64, height: f64 }\n#[allow(dead_code)]\nstruct Triangle  { length: f64, height: f64 }\n\n// 泛型 `T` 必须实现 `Debug` 。只要满足这点，无论什么类型\n// 都可以让下面函数正常工作。\nfn print_debug<T: Debug>(t: &T) {\n    println!("{:?}", t);\n}\n\n// `T` 必须实现 `HasArea`。任意符合该约束的泛型的实例\n// 都可访问 `HasArea` 的 `area` 函数\nfn area<T: HasArea>(t: &T) -> f64 { t.area() }\n\nfn main() {\n    let rectangle = Rectangle { length: 3.0, height: 4.0 };\n    let _triangle = Triangle  { length: 3.0, height: 4.0 };\n\n    print_debug(&rectangle);\n    println!("Area: {}", area(&rectangle));\n\n    //print_debug(&_triangle);\n    //println!("Area: {}", area(&_triangle));\n    // ^ 试一试：取消上述语句的注释。\n    // | 报错：未实现 `Debug` 或 `HasArea`。\n}\n')])])]),n("p",[t._v("多说一句，某些情况下也可使用 "),n("RouterLink",{attrs:{to:"/generics/where.html"}},[n("code",[t._v("where")])]),t._v(" 分句来形成约束，这拥有更好的表现力。")],1),t._v(" "),n("h3",{attrs:{id:"参见："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[t._v("#")]),t._v(" 参见：")]),t._v(" "),n("p",[n("RouterLink",{attrs:{to:"/hello/print.html"}},[n("code",[t._v("std::fmt")])]),t._v(", "),n("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[n("code",[t._v("struct")])]),t._v(", 和 "),n("RouterLink",{attrs:{to:"/trait.html"}},[n("code",[t._v("trait")])])],1)])}),[],!1,null,null,null);e.default=r.exports}}]);