(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{545:function(e,n,r){"use strict";r.r(n);var t=r(4),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"指针和引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#指针和引用"}},[e._v("#")]),e._v(" 指针和引用")]),e._v(" "),r("p",[e._v("对指针来说，解构（destructure）和解引用（dereference）要区分开，因为这两者的概念\n是不同的，和 "),r("code",[e._v("C")]),e._v(" 那样的语言用法不一样。")]),e._v(" "),r("ul",[r("li",[e._v("解引用使用 "),r("code",[e._v("*")])]),e._v(" "),r("li",[e._v("解构使用 "),r("code",[e._v("&")]),e._v("、"),r("code",[e._v("ref")]),e._v("、和 "),r("code",[e._v("ref mut")])])]),e._v(" "),r("div",{staticClass:"language-rust,editable extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('fn main() {\n    // 获得一个 `i32` 类型的引用。`&` 表示取引用。\n    let reference = &4;\n\n    match reference {\n        // 如果用 `&val` 这个模式去匹配 `reference`，就相当于做这样的比较：\n        // `&i32`（译注：即 `reference` 的类型）\n        //    |\n        // `&val`（译注：即用于匹配的模式）\n        // ^ 我们看到，如果去掉匹配的 `&`，`i32` 应当赋给 `val`。\n        // 译注：因此可用 `val` 表示被 `reference` 引用的值 4。\n        &val => println!("Got a value via destructuring: {:?}", val),\n    }\n\n    // 如果不想用 `&`，需要在匹配前解引用。\n    match *reference {\n        val => println!("Got a value via dereferencing: {:?}", val),\n    }\n\n    // 如果一开始就不用引用，会怎样？ `reference` 是一个 `&` 类型，因为赋值语句\n    // 的右边已经是一个引用。但下面这个不是引用，因为右边不是。\n    let _not_a_reference = 3;\n\n    // Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。\n    // 下面这行将得到一个引用。\n    let ref _is_a_reference = 3;\n\n    // 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。\n    let value = 5;\n    let mut mut_value = 6;\n\n    // 使用 `ref` 关键字来创建引用。\n    // 译注：下面的 r 是 `&i32` 类型，它像 `i32` 一样可以直接打印，因此用法上\n    // 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能\n    // 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解\n    // 引用。\n    match value {\n        ref r => println!("Got a reference to a value: {:?}", r),\n    }\n\n    // 类似地使用 `ref mut`。\n    match mut_value {\n        ref mut m => {\n            // 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。\n            *m += 10;\n            println!("We added 10. `mut_value`: {:?}", m);\n        },\n    }\n}\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);