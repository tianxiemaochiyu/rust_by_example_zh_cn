(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{564:function(e,n,t){"use strict";t.r(n);var _=t(4),a=Object(_.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"泛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[e._v("#")]),e._v(" 泛型")]),e._v(" "),t("p",[t("strong",[e._v("泛型")]),e._v("（generic）是关于泛化类型和函数功能，以扩大其适用范围的话题。泛型极大地\n减少了代码的重复，但它自身的语法很要求细心。也就是说，采用泛型意味着仔细地指定\n泛型类型具体化时，什么样的具体类型是合法的。泛型最简单和常用的用法是用于类型参数。")]),e._v(" "),t("blockquote",[t("p",[e._v("译注：定义泛型类型或泛型函数之类的东西时，我们会用 "),t("code",[e._v("<A>")]),e._v(" 或者 "),t("code",[e._v("<T>")]),e._v(" 这类标记\n作为类型的代号，就像函数的形参一样。在使用时，为把 "),t("code",[e._v("<A>")]),e._v("、"),t("code",[e._v("<T>")]),e._v(" 具体化，我们\n会把类型说明像实参一样使用，像是 "),t("code",[e._v("<i32>")]),e._v(" 这样。这两种把（泛型的或具体的）类型\n当作参数的用法就是"),t("strong",[e._v("类型参数")]),e._v("。")])]),e._v(" "),t("p",[e._v("泛型的类型参数是使用尖括号和"),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/CamelCase",target:"_blank",rel:"noopener noreferrer"}},[e._v("大驼峰命名"),t("OutboundLink")],1),e._v("的名称："),t("code",[e._v("<Aaa, Bbb, ...>")]),e._v("\n来指定的。泛型类型参数一般用 "),t("code",[e._v("<T>")]),e._v(" 来表示。在 Rust 中，“泛型的” 除了表示\n类型，还表示可以接受一个或多个泛型类型参数 "),t("code",[e._v("<T>")]),e._v(" 的任何内容。任何用泛型类型参数\n表示的类型都是泛型，其他的类型都是具体（非泛型）类型。")]),e._v(" "),t("p",[e._v("例如定义一个名为 "),t("code",[e._v("foo")]),e._v(" 的 "),t("strong",[e._v("泛型函数")]),e._v("，它可接受类型为 "),t("code",[e._v("T")]),e._v(" 的任何参数 "),t("code",[e._v("arg")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language-rust,ignore extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fn foo<T>(arg: T) { ... }\n")])])]),t("p",[e._v("因为我们使用了泛型类型参数 "),t("code",[e._v("<T>")]),e._v("，所以这里的 "),t("code",[e._v("(arg: T)")]),e._v(" 中的 "),t("code",[e._v("T")]),e._v(" 就是泛型\n类型。即使 "),t("code",[e._v("T")]),e._v(" 在之前被定义为 "),t("code",[e._v("struct")]),e._v("，这里的 "),t("code",[e._v("T")]),e._v(" 仍然代表泛型。")]),e._v(" "),t("p",[e._v("下面例子展示了泛型语法的使用：")]),e._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 一个具体类型 `A`。\nstruct A;\n\n// 在定义类型 `Single` 时，第一次使用类型 `A` 之前没有写 `<A>`。\n// 因此，`Single` 是个具体类型，`A` 取上面的定义。\nstruct Single(A);\n//            ^ 这里是 `Single` 对类型 `A` 的第一次使用。\n\n// 此处 `<T>` 在第一次使用 `T` 前出现，所以 `SingleGen` 是一个泛型类型。\n// 因为 `T` 是泛型的，所以它可以是任何类型，包括在上面定义的具体类型 `A`。\nstruct SingleGen<T>(T);\n\nfn main() {\n    // `Single` 是具体类型，并且显式地使用类型 `A`。\n    let _s = Single(A);\n    \n    // 创建一个 `SingleGen<char>` 类型的变量 `_char`，并令其值为 `SingleGen('a')`\n    // 这里的 `SingleGen` 的类型参数是显式指定的。\n    let _char: SingleGen<char> = SingleGen('a');\n\n    // `SingleGen` 的类型参数也可以隐式地指定。\n    let _t    = SingleGen(A); // 使用在上面定义的 `A`。\n    let _i32  = SingleGen(6); // 使用 `i32` 类型。\n    let _char = SingleGen('a'); // 使用 `char`。\n}\n")])])]),t("h3",{attrs:{id:"参见："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[e._v("#")]),e._v(" 参见：")]),e._v(" "),t("p",[t("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[t("code",[e._v("struct")])])],1)])}),[],!1,null,null,null);n.default=a.exports}}]);