(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{558:function(n,e,t){"use strict";t.r(e);var r=t(4),o=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"作为输入参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作为输入参数"}},[n._v("#")]),n._v(" 作为输入参数")]),n._v(" "),t("p",[n._v("虽然 Rust 无需类型说明就能在大多数时候完成变量捕获，但在编写函数时，这种模糊写法\n是不允许的。当以闭包作为输入参数时，必须指出闭包的完整类型，它是通过使用以下\n"),t("code",[n._v("trait")]),n._v(" 中的一种来指定的。其受限制程度按以下顺序递减：")]),n._v(" "),t("ul",[t("li",[t("code",[n._v("Fn")]),n._v("：表示捕获方式为通过引用（"),t("code",[n._v("&T")]),n._v("）的闭包")]),n._v(" "),t("li",[t("code",[n._v("FnMut")]),n._v("：表示捕获方式为通过可变引用（"),t("code",[n._v("&mut T")]),n._v("）的闭包")]),n._v(" "),t("li",[t("code",[n._v("FnOnce")]),n._v("：表示捕获方式为通过值（"),t("code",[n._v("T")]),n._v("）的闭包")])]),n._v(" "),t("blockquote",[t("p",[n._v("译注：顺序之所以是这样，是因为 "),t("code",[n._v("&T")]),n._v(" 只是获取了不可变的引用，"),t("code",[n._v("&mut T")]),n._v(" 则可以改变\n变量，"),t("code",[n._v("T")]),n._v(" 则是拿到了变量的所有权而非借用。")])]),n._v(" "),t("p",[n._v("对闭包所要捕获的每个变量，编译器都将以限制最少的方式来捕获。")]),n._v(" "),t("blockquote",[t("p",[n._v("译注：这句可能说得不对，事实上是在满足使用需求的前提下尽量以限制最多的方式捕获。")])]),n._v(" "),t("p",[n._v("例如用一个类型说明为 "),t("code",[n._v("FnOnce")]),n._v(" 的闭包作为参数。这说明闭包可能采取 "),t("code",[n._v("&T")]),n._v("，"),t("code",[n._v("&mut T")]),n._v("\n或 "),t("code",[n._v("T")]),n._v(" 中的一种捕获方式，但编译器最终是根据所捕获变量在闭包里的使用情况决定捕获\n方式。")]),n._v(" "),t("p",[n._v("这是因为如果能以移动的方式捕获变量，则闭包也有能力使用其他方式借用变量。注意\n反过来就不再成立：如果参数的类型说明是 "),t("code",[n._v("Fn")]),n._v("，那么不允许该闭包通过 "),t("code",[n._v("&mut T")]),n._v("\n或 "),t("code",[n._v("T")]),n._v(" 捕获变量。")]),n._v(" "),t("p",[n._v("在下面的例子中，试着分别用一用 "),t("code",[n._v("Fn")]),n._v("、"),t("code",[n._v("FnMut")]),n._v(" 和 "),t("code",[n._v("FnOnce")]),n._v("，看看会发生什么：")]),n._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 该函数将闭包作为参数并调用它。\nfn apply<F>(f: F) where\n    // 闭包没有输入值和返回值。\n    F: FnOnce() {\n    // ^ 试一试：将 `FnOnce` 换成 `Fn` 或 `FnMut`。\n\n    f();\n}\n\n// 输入闭包，返回一个 `i32` 整型的函数。\nfn apply_to_3<F>(f: F) -> i32 where\n    // 闭包处理一个 `i32` 整型并返回一个 `i32` 整型。\n    F: Fn(i32) -> i32 {\n\n    f(3)\n}\n\nfn main() {\n    use std::mem;\n    \n    let greeting = "hello";\n    // 不可复制的类型。\n    // `to_owned` 从借用的数据创建有所有权的数据。\n    let mut farewell = "goodbye".to_owned();\n\n    // 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。\n    let diary = || {\n        // `greeting` 通过引用捕获，故需要闭包是 `Fn`。\n        println!("I said {}.", greeting);\n\n        // 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。\n        // 现在需要 `FnMut`。\n        farewell.push_str("!!!");\n        println!("Then I screamed {}.", farewell);\n        println!("Now I can sleep. zzzzz");\n\n        // 手动调用 drop 又要求闭包通过值获取 `farewell`。\n        // 现在需要 `FnOnce`。\n        mem::drop(farewell);\n    };\n\n    // 以闭包作为参数，调用函数 `apply`。\n    apply(diary);\n\n    // 闭包 `double` 满足 `apply_to_3` 的 trait 约束。\n    let double = |x| 2 * x;\n\n    println!("3 doubled: {}", apply_to_3(double));\n}\n')])])]),t("h3",{attrs:{id:"参见："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[n._v("#")]),n._v(" 参见：")]),n._v(" "),t("p",[t("a",{attrs:{href:"http://doc.rust-lang.org/std/mem/fn.drop.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[n._v("std::mem::drop")]),t("OutboundLink")],1),n._v(", "),t("a",{attrs:{href:"http://doc.rust-lang.org/std/ops/trait.Fn.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[n._v("Fn")]),t("OutboundLink")],1),n._v(", "),t("a",{attrs:{href:"http://doc.rust-lang.org/std/ops/trait.FnMut.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[n._v("FnMut")]),t("OutboundLink")],1),n._v(", 和 "),t("a",{attrs:{href:"http://doc.rust-lang.org/std/ops/trait.FnOnce.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[n._v("FnOnce")]),t("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=o.exports}}]);