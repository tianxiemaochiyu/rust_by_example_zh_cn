(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{518:function(n,r,e){"use strict";e.r(r);var t=e(4),s=Object(t.a)({},(function(){var n=this,r=n.$createElement,e=n._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"定义一个错误类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义一个错误类型"}},[n._v("#")]),n._v(" 定义一个错误类型")]),n._v(" "),e("p",[n._v("有时候把所有不同的错误都视为一种错误类型会简化代码。我们将用一个自定义错误类型来\n演示这一点。")]),n._v(" "),e("p",[n._v("Rust 允许我们定义自己的错误类型。一般来说，一个 “好的” 错误类型应当：")]),n._v(" "),e("ul",[e("li",[n._v("用同一个类型代表了多种错误")]),n._v(" "),e("li",[n._v("向用户提供了清楚的错误信息")]),n._v(" "),e("li",[n._v("能够容易地与其他类型比较\n"),e("ul",[e("li",[n._v("好的例子："),e("code",[n._v("Err(EmptyVec)")])]),n._v(" "),e("li",[n._v("坏的例子："),e("code",[n._v('Err("Please use a vector with at least one element".to_owned())')])])])]),n._v(" "),e("li",[n._v("能够容纳错误的具体信息\n"),e("ul",[e("li",[n._v("好的例子："),e("code",[n._v("Err(BadChar(c, position))")])]),n._v(" "),e("li",[n._v("坏的例子："),e("code",[n._v('Err("+ cannot be used here".to_owned())')])])])]),n._v(" "),e("li",[n._v("能够与其他错误很好地整合")])]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('use std::error;\nuse std::fmt;\n\ntype Result<T> = std::result::Result<T, DoubleError>;\n\n#[derive(Debug, Clone)]\n// 定义我们的错误类型，这种类型可以根据错误处理的实际情况定制。\n// 我们可以完全自定义错误类型，也可以在类型中完全采用底层的错误实现，\n// 也可以介于二者之间。\nstruct DoubleError;\n\n// 错误的生成与它如何显示是完全没关系的。没有必要担心复杂的逻辑会导致混乱的显示。\n//\n// 注意我们没有储存关于错误的任何额外信息，也就是说，如果不修改我们的错误类型定义的话，\n// 就无法指明是哪个字符串解析失败了。\nimpl fmt::Display for DoubleError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, "invalid first item to double")\n    }\n}\n\n// 为 `DoubleError` 实现 `Error` trait，这样其他错误可以包裹这个错误类型。\nimpl error::Error for DoubleError {\n    fn source(&self) -> Option<&(dyn error::Error + \'static)> {\n        // 泛型错误，没有记录其内部原因。\n        None\n    }\n}\n\nfn double_first(vec: Vec<&str>) -> Result<i32> {\n    vec.first()\n       // 把错误换成我们的新类型。\n       .ok_or(DoubleError)\n       .and_then(|s| {\n            s.parse::<i32>()\n                // 这里也换成新类型。\n                .map_err(|_| DoubleError)\n                .map(|i| 2 * i)\n        })\n}\n\nfn print(result: Result<i32>) {\n    match result {\n        Ok(n)  => println!("The first doubled is {}", n),\n        Err(e) => println!("Error: {}", e),\n    }\n}\n\nfn main() {\n    let numbers = vec!["42", "93", "18"];\n    let empty = vec![];\n    let strings = vec!["tofu", "93", "18"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n')])])])])}),[],!1,null,null,null);r.default=s.exports}}]);