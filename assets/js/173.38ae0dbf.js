(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{652:function(n,t,e){"use strict";e.r(t);var r=e(4),a=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"测试实例：map-reduce"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试实例：map-reduce"}},[n._v("#")]),n._v(" 测试实例：map-reduce")]),n._v(" "),e("p",[n._v("Rust 使数据的并行化处理非常简单，在 Rust 中你无需面对并行处理的很多传统难题。")]),n._v(" "),e("p",[n._v("标准库提供了开箱即用的线程类型，把它和 Rust 的所有权概念与别名规则结合\n起来，可以自动地避免数据竞争（data race）。")]),n._v(" "),e("p",[n._v("当某状态对某线程是可见的，别名规则（即一个可变引用 XOR 一些只读引用。译注：XOR\n是异或的意思，即「二者仅居其一」）就自动地避免了别的线程对它的操作。（当需要同步\n处理时，请使用 "),e("code",[n._v("Mutex")]),n._v(" 或 "),e("code",[n._v("Channel")]),n._v(" 这样的同步类型。）")]),n._v(" "),e("p",[n._v("在本例中，我们将会计算一堆数字中每一位的和。我们将把它们分成几块，放入不同的\n线程。每个线程会把自己那一块数字的每一位加起来，之后我们再把每个线程提供的结果\n再加起来。")]),n._v(" "),e("p",[n._v("注意到，虽然我们在线程之间传递了引用，但 Rust 理解我们是在传递只读的引用，因此\n不会发生数据竞争等不安全的事情。另外，因为我们把数据块 "),e("code",[n._v("move")]),n._v(" 到了线程中，Rust\n会保证数据存活至线程退出，因此不会产生悬挂指针。")]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('use std::thread;\n\n// 这是 `main` 线程\nfn main() {\n\n    // 这是我们要处理的数据。\n    // 我们会通过线程实现 map-reduce 算法，从而计算每一位的和\n    // 每个用空白符隔开的块都会分配给单独的线程来处理\n    //\n    // 试一试：插入空格，看看输出会怎样变化！\n    let data = "86967897737416471853297327050364959\n11861322575564723963297542624962850\n70856234701860851907960690014725639\n38397966707106094172783238747669219\n52380795257888236525459303330302837\n58495327135744041048897885734297812\n69920216438980873548808413720956532\n16278424637452589860345374828574668";\n\n    // 创建一个向量，用于储存将要创建的子线程\n    let mut children = vec![];\n\n    /*************************************************************************\n     * "Map" 阶段\n     *\n     * 把数据分段，并进行初始化处理\n     ************************************************************************/\n\n    // 把数据分段，每段将会单独计算\n    // 每段都是完整数据的一个引用（&str）\n    let chunked_data = data.split_whitespace();\n\n    // 对分段的数据进行迭代。\n    // .enumerate() 会把当前的迭代计数与被迭代的元素以元组 (index, element)\n    // 的形式返回。接着立即使用 “解构赋值” 将该元组解构成两个变量，\n    // `i` 和 `data_segment`。\n    for (i, data_segment) in chunked_data.enumerate() {\n        println!("data segment {} is \\"{}\\"", i, data_segment);\n\n        // 用单独的线程处理每一段数据\n        //\n        // spawn() 返回新线程的句柄（handle），我们必须拥有句柄，\n        // 才能获取线程的返回值。\n        //\n        // \'move || -> u32\' 语法表示该闭包：\n        // * 没有参数（\'||\'）\n        // * 会获取所捕获变量的所有权（\'move\'）\n        // * 返回无符号 32 位整数（\'-> u32\'）\n        //\n        // Rust 可以根据闭包的内容推断出 \'-> u32\'，所以我们可以不写它。\n        //\n        // 试一试：删除 \'move\'，看看会发生什么\n        children.push(thread::spawn(move || -> u32 {\n            // 计算该段的每一位的和：\n            let result = data_segment\n                        // 对该段中的字符进行迭代..\n                        .chars()\n                        // ..把字符转成数字..\n                        .map(|c| c.to_digit(10).expect("should be a digit"))\n                        // ..对返回的数字类型的迭代器求和\n                        .sum();\n\n            // println! 会锁住标准输出，这样各线程打印的内容不会交错在一起\n            println!("processed segment {}, result={}", i, result);\n\n            // 不需要 “return”，因为 Rust 是一种 “表达式语言”，每个代码块中\n            // 最后求值的表达式就是代码块的值。\n            result\n\n        }));\n    }\n\n\n    /*************************************************************************\n     * "Reduce" 阶段\n     *\n     * 收集中间结果，得出最终结果\n     ************************************************************************/\n\n    // 把每个线程产生的中间结果收入一个新的向量中\n    let mut intermediate_sums = vec![];\n    for child in children {\n        // 收集每个子线程的返回值\n        let intermediate_sum = child.join().unwrap();\n        intermediate_sums.push(intermediate_sum);\n    }\n\n    // 把所有中间结果加起来，得到最终结果\n    //\n    // 我们用 “涡轮鱼” 写法 ::<> 来为 sum() 提供类型提示。\n    //\n    // 试一试：不使用涡轮鱼写法，而是显式地指定 intermediate_sums 的类型\n    let final_result = intermediate_sums.iter().sum::<u32>();\n\n    println!("Final sum result: {}", final_result);\n}\n\n\n')])])]),e("h3",{attrs:{id:"作业"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作业"}},[n._v("#")]),n._v(" 作业")]),n._v(" "),e("p",[n._v("根据用户输入的数据来决定线程的数量是不明智的。如果用户输入的数据中有一大堆空格\n怎么办？我们"),e("strong",[n._v("真的")]),n._v("想要创建 2000 个线程吗？")]),n._v(" "),e("p",[n._v("请修改程序，使得数据总是被分成有限数目的段，这个数目是由程序开头的静态常量决定的。")]),n._v(" "),e("h3",{attrs:{id:"参见"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参见"}},[n._v("#")]),n._v(" 参见:")]),n._v(" "),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/std_misc/threads.html"}},[n._v("线程")])],1),n._v(" "),e("li",[e("RouterLink",{attrs:{to:"/std/vec.html"}},[n._v("向量")]),n._v("和"),e("RouterLink",{attrs:{to:"/trait/iter.html"}},[n._v("迭代器")])],1),n._v(" "),e("li",[e("RouterLink",{attrs:{to:"/fn/closures.html"}},[n._v("闭包")]),n._v("、"),e("RouterLink",{attrs:{to:"/scope/move.html"}},[n._v("移动")]),n._v("语义和"),e("a",{attrs:{href:"https://doc.rust-lang.org/book/ch13-01-closures.html#closures-can-capture-their-environment",target:"_blank",rel:"noopener noreferrer"}},[e("code",[n._v("move")]),n._v("闭包"),e("OutboundLink")],1)],1),n._v(" "),e("li",[e("a",{attrs:{href:"https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values",target:"_blank",rel:"noopener noreferrer"}},[n._v("解构"),e("OutboundLink")],1),n._v("赋值")]),n._v(" "),e("li",[n._v("使用"),e("a",{attrs:{href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect",target:"_blank",rel:"noopener noreferrer"}},[n._v("涡轮鱼写法"),e("OutboundLink")],1),n._v("帮助类型推断")]),n._v(" "),e("li",[e("RouterLink",{attrs:{to:"/error/option_unwrap.html"}},[n._v("unwrap vs. expect")])],1),n._v(" "),e("li",[e("a",{attrs:{href:"https://doc.rust-lang.org/book/loops.html#enumerate",target:"_blank",rel:"noopener noreferrer"}},[n._v("枚举类型"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=a.exports}}]);