(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{630:function(n,a,e){"use strict";e.r(a);var o=e(4),t=Object(o.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"更改或自定义关键字类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更改或自定义关键字类型"}},[n._v("#")]),n._v(" 更改或自定义关键字类型")]),n._v(" "),e("p",[n._v("任何实现了 "),e("code",[n._v("Eq")]),n._v(" 和 "),e("code",[n._v("Hash")]),n._v(" trait 的类型都可以充当 "),e("code",[n._v("HashMap")]),n._v(" 的键。这包括：")]),n._v(" "),e("ul",[e("li",[e("code",[n._v("bool")]),n._v(" （当然这个用处不大，因为只有两个可能的键）")]),n._v(" "),e("li",[e("code",[n._v("int")]),n._v("，"),e("code",[n._v("unit")]),n._v("，以及其他整数类型")]),n._v(" "),e("li",[e("code",[n._v("String")]),n._v(" 和 "),e("code",[n._v("&str")]),n._v("（友情提示：如果使用 "),e("code",[n._v("String")]),n._v(" 作为键来创建 "),e("code",[n._v("HashMap")]),n._v("，则可以\n将 "),e("code",[n._v("&str")]),n._v(" 作为散列表的 "),e("code",[n._v(".get()")]),n._v(" 方法的参数，以获取值）")])]),n._v(" "),e("p",[n._v("注意到 "),e("code",[n._v("f32")]),n._v(" 和 "),e("code",[n._v("f64")]),n._v(" "),e("strong",[n._v("没有")]),n._v("实现 "),e("code",[n._v("Hash")]),n._v("，这很大程度上是由于若使用浮点数作为\n散列表的键，"),e("a",{attrs:{href:"http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems",target:"_blank",rel:"noopener noreferrer"}},[n._v("浮点精度误差"),e("OutboundLink")],1),n._v("会很容易导致错误。")]),n._v(" "),e("p",[n._v("对于所有的集合类（collection class），如果它们包含的类型都分别实现了 "),e("code",[n._v("Eq")]),n._v("\n和 "),e("code",[n._v("Hash")]),n._v("，那么这些集合类也就实现了 "),e("code",[n._v("Eq")]),n._v(" 和 "),e("code",[n._v("Hash")]),n._v("。例如，若 "),e("code",[n._v("T")]),n._v(" 实现了\n"),e("code",[n._v("Hash")]),n._v("，则 "),e("code",[n._v("Vec<T>")]),n._v(" 也实现了 "),e("code",[n._v("Hash")]),n._v("。")]),n._v(" "),e("p",[n._v("对自定义类型可以轻松地实现 "),e("code",[n._v("Eq")]),n._v(" 和 "),e("code",[n._v("Hash")]),n._v("，只需加上一行代码："),e("code",[n._v("#[derive(PartialEq, Eq, Hash)]")]),n._v("。")]),n._v(" "),e("p",[n._v("编译器将会完成余下的工作。如果你想控制更多的细节，你可以手动\n实现 "),e("code",[n._v("Eq")]),n._v(" 和/或 "),e("code",[n._v("Hash")]),n._v("。本指南不包含实现 "),e("code",[n._v("Hash")]),n._v(" 的细节内容。")]),n._v(" "),e("p",[n._v("为了试验 "),e("code",[n._v("HashMap")]),n._v(" 中的 "),e("code",[n._v("struct")]),n._v("，让我们试着做一个非常简易的用户登录系统：")]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('use std::collections::HashMap;\n\n// Eq 要求你对此类型推导 PartiaEq。\n#[derive(PartialEq, Eq, Hash)]\nstruct Account<\'a>{\n    username: &\'a str,\n    password: &\'a str,\n}\n\nstruct AccountInfo<\'a>{\n    name: &\'a str,\n    email: &\'a str,\n}\n\ntype Accounts<\'a> = HashMap<Account<\'a>, AccountInfo<\'a>>;\n\nfn try_logon<\'a>(accounts: &Accounts<\'a>,\n        username: &\'a str, password: &\'a str){\n    println!("Username: {}", username);\n    println!("Password: {}", password);\n    println!("Attempting logon...");\n\n    let logon = Account {\n        username: username,\n        password: password,\n    };\n\n    match accounts.get(&logon) {\n        Some(account_info) => {\n            println!("Successful logon!");\n            println!("Name: {}", account_info.name);\n            println!("Email: {}", account_info.email);\n        },\n        _ => println!("Login failed!"),\n    }\n}\n\nfn main(){\n    let mut accounts: Accounts = HashMap::new();\n\n    let account = Account {\n        username: "j.everyman",\n        password: "password123",\n    };\n\n    let account_info = AccountInfo {\n        name: "John Everyman",\n        email: "j.everyman@email.com",\n    };\n\n    accounts.insert(account, account_info);\n\n    try_logon(&accounts, "j.everyman", "psasword123");\n\n    try_logon(&accounts, "j.everyman", "password123");\n}\n')])])])])}),[],!1,null,null,null);a.default=t.exports}}]);