(window.webpackJsonp=window.webpackJsonp||[]).push([[147],{626:function(n,e,t){"use strict";t.r(e);var o=t(4),i=Object(o.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"箱子、栈和堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箱子、栈和堆"}},[n._v("#")]),n._v(" 箱子、栈和堆")]),n._v(" "),t("p",[n._v("在 Rust 中，所有值默认都是栈分配的。通过创建 "),t("code",[n._v("Box<T>")]),n._v("，可以把值"),t("strong",[n._v("装箱")]),n._v("（boxed）来\n使它在堆上分配。箱子（box，即 "),t("code",[n._v("Box<T>")]),n._v(" 类型的实例）是一个智能指针，指向堆分配\n的 "),t("code",[n._v("T")]),n._v(" 类型的值。当箱子离开作用域时，它的析构函数会被调用，内部的对象会被\n销毁，堆上分配的内存也会被释放。")]),n._v(" "),t("p",[n._v("被装箱的值可以使用 "),t("code",[n._v("*")]),n._v(" 运算符进行解引用；这会移除掉一层装箱。")]),n._v(" "),t("div",{staticClass:"language-rust,editalbe extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('use std::mem;\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n#[allow(dead_code)]\nstruct Rectangle {\n    p1: Point,\n    p2: Point,\n}\n\nfn origin() -> Point {\n    Point { x: 0.0, y: 0.0 }\n}\n\nfn boxed_origin() -> Box<Point> {\n    // 在堆上分配这个点（point），并返回一个指向它的指针\n    Box::new(Point { x: 0.0, y: 0.0 })\n}\n\nfn main() {\n    // （所有的类型标注都不是必需的）\n    // 栈分配的变量\n    let point: Point = origin();\n    let rectangle: Rectangle = Rectangle {\n        p1: origin(),\n        p2: Point { x: 3.0, y: 4.0 }\n    };\n\n    // 堆分配的 rectangle（矩形）\n    let boxed_rectangle: Box<Rectangle> = Box::new(Rectangle {\n        p1: origin(),\n        p2: origin()\n    });\n\n    // 函数的输出可以装箱\n    let boxed_point: Box<Point> = Box::new(origin());\n\n    // 两层装箱\n    let box_in_a_box: Box<Box<Point>> = Box::new(boxed_origin());\n\n    println!("Point occupies {} bytes in the stack",\n             mem::size_of_val(&point));\n    println!("Rectangle occupies {} bytes in the stack",\n             mem::size_of_val(&rectangle));\n\n    // box 的宽度就是指针宽度\n    println!("Boxed point occupies {} bytes in the stack",\n             mem::size_of_val(&boxed_point));\n    println!("Boxed rectangle occupies {} bytes in the stack",\n             mem::size_of_val(&boxed_rectangle));\n    println!("Boxed box occupies {} bytes in the stack",\n             mem::size_of_val(&box_in_a_box));\n\n    // 将包含在 `boxed_point` 中的数据复制到 `unboxed_point`\n    let unboxed_point: Point = *boxed_point;\n    println!("Unboxed point occupies {} bytes in the stack",\n             mem::size_of_val(&unboxed_point));\n}\n')])])])])}),[],!1,null,null,null);e.default=i.exports}}]);