(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{619:function(e,n,t){"use strict";t.r(n);var r=t(4),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"结构体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构体"}},[e._v("#")]),e._v(" 结构体")]),e._v(" "),t("p",[e._v("在结构体中标注生命周期也和函数的类似：")]),e._v(" "),t("div",{staticClass:"language-rust,editable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 一个 `Borrowed` 类型，含有一个指向 `i32` 类型的引用。\n// 该引用必须比 `Borrowed` 寿命更长。\n#[derive(Debug)]\nstruct Borrowed<\'a>(&\'a i32);\n\n// 和前面类似，这里的两个引用都必须比这个结构体长寿。\n#[derive(Debug)]\nstruct NamedBorrowed<\'a> {\n    x: &\'a i32,\n    y: &\'a i32,\n}\n\n// 一个枚举类型，其取值不是 `i32` 类型就是一个指向 `i32` 的引用。\n#[derive(Debug)]\nenum Either<\'a> {\n    Num(i32),\n    Ref(&\'a i32),\n}\n\nfn main() {\n    let x = 18;\n    let y = 15;\n\n    let single = Borrowed(&x);\n    let double = NamedBorrowed { x: &x, y: &y };\n    let reference = Either::Ref(&x);\n    let number    = Either::Num(y);\n\n    println!("x is borrowed in {:?}", single);\n    println!("x and y are borrowed in {:?}", double);\n    println!("x is borrowed in {:?}", reference);\n    println!("y is *not* borrowed in {:?}", number);\n}\n')])])]),t("h3",{attrs:{id:"参见："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[e._v("#")]),e._v(" 参见：")]),e._v(" "),t("p",[t("RouterLink",{attrs:{to:"/custom_types/structs.html"}},[t("code",[e._v("structs")])])],1)])}),[],!1,null,null,null);n.default=a.exports}}]);