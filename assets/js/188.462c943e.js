(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{666:function(e,t,n){"use strict";n.r(t);var r=n(4),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"类型推断"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类型推断"}},[e._v("#")]),e._v(" 类型推断")]),e._v(" "),n("p",[e._v("Rust 的类型推断引擎是很聪明的，它不只是在初始化时看看"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue",target:"_blank",rel:"noopener noreferrer"}},[e._v("右值"),n("OutboundLink")],1),e._v("（r-value）的\n类型而已，它还会考察变量之后会怎样使用，借此推断类型。这是一个类型推导的进阶例子：")]),e._v(" "),n("div",{staticClass:"language-rust,editable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('fn main() {\n    // 因为有类型说明，编译器知道 `elem` 的类型是 u8。\n    let elem = 5u8;\n\n    // 创建一个空向量（vector，即不定长的，可以增长的数组）。\n    let mut vec = Vec::new();\n    // 现在编译器还不知道 `vec` 的具体类型，只知道它是某种东西构成的向量（`Vec<_>`）\n    \n    // 在向量中插入 `elem`。\n    vec.push(elem);\n    // 啊哈！现在编译器知道 `vec` 是 u8 的向量了（`Vec<u8>`）。\n    // 试一试 ^ 注释掉 `vec.push(elem)` 这一行。\n\n    println!("{:?}", vec);\n}\n')])])]),n("p",[e._v("没有必要写类型说明，编译器和程序员皆大欢喜！")])])}),[],!1,null,null,null);t.default=a.exports}}]);