(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{629:function(s,a,t){"use strict";t.r(a);var n=t(4),r=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"panic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#panic"}},[s._v("#")]),s._v(" "),t("code",[s._v("panic!")])]),s._v(" "),t("p",[t("code",[s._v("panic!")]),s._v(" 宏可用于产生一个 panic （恐慌），并开始回退（unwind）它的栈。在回退栈\n的同时，运行时将会释放该线程所"),t("strong",[s._v("拥有")]),s._v("的所有资源，这是通过调用线程中所有对象的\n析构函数完成的。")]),s._v(" "),t("p",[s._v("因为我们正在处理的程序只有一个线程，"),t("code",[s._v("panic!")]),s._v(" 将会引发程序报告 panic 消息并退出。")]),s._v(" "),t("div",{staticClass:"language-rust,editable,ignore,mdbook-runnable extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('// 整型除法（/）的重新实现\nfn division(dividend: i32, divisor: i32) -> i32 {\n    if divisor == 0 {\n        // 除以 0 会引发 panic\n        panic!("division by zero");\n    } else {\n        dividend / divisor\n    }\n}\n\n// `main` 任务\nfn main() {\n    // 堆分配的整数\n    let _x = Box::new(0i32);\n\n    // 此操作将会引发一个任务失败\n    division(3, 0);\n\n    println!("This point won\'t be reached!");\n\n    // `_x` 应当会在此处被销毁\n}\n')])])]),t("p",[s._v("可以看到，"),t("code",[s._v("panic!")]),s._v(" 不会泄露内存：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("$ rustc panic.rs "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" valgrind ./panic\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" Memcheck, a memory error detector\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" Copyright "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("C"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2002")]),s._v("-2013, and GNU GPL"),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'d, by Julian Seward et al.\n==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info\n==4401== Command: ./panic\n==4401== \nthread '")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("main"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("' panicked at '")]),s._v("division by zero', panic.rs:5\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" \n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" HEAP SUMMARY:\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v("     "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("in")]),s._v(" use at exit: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" bytes "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("in")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" blocks\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v("   total heap usage: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("18")]),s._v(" allocs, "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("18")]),s._v(" frees, "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1,648")]),s._v(" bytes allocated\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" \n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" All heap blocks were freed -- no leaks are possible\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" \n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" For counts of detected and suppressed errors, rerun with: -v\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4401")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" ERROR SUMMARY: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" errors from "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" contexts "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("suppressed: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" from "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);