(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{522:function(e,t,n){"use strict";n.r(t);var r=n(4),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"处理多种错误类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#处理多种错误类型"}},[e._v("#")]),e._v(" 处理多种错误类型")]),e._v(" "),n("p",[e._v("前面出现的例子都是很方便的情况；都是 "),n("code",[e._v("Result")]),e._v(" 和其他 "),n("code",[e._v("Result")]),e._v(" 交互，还有 "),n("code",[e._v("Option")]),e._v("\n和其他 "),n("code",[e._v("Option")]),e._v(" 交互。")]),e._v(" "),n("p",[e._v("有时 "),n("code",[e._v("Option")]),e._v(" 需要和 "),n("code",[e._v("Result")]),e._v(" 进行交互，或是 "),n("code",[e._v("Result<T, Error1>")]),e._v(" 需要和\n"),n("code",[e._v("Result<T, Error2>")]),e._v(" 进行交互。在这类情况下，我们想要以一种方式来管理不同的错误\n类型，使得它们可组合且易于交互。")]),e._v(" "),n("p",[e._v("在下面代码中，"),n("code",[e._v("unwrap")]),e._v(" 的两个实例生成了不同的错误类型。"),n("code",[e._v("Vec::first")]),e._v(" 返回一个\n"),n("code",[e._v("Option")]),e._v("，而 "),n("code",[e._v("parse::<i32>")]),e._v(" 返回一个 "),n("code",[e._v("Result<i32, ParseIntError>")]),e._v("：")]),e._v(" "),n("div",{staticClass:"language-rust,editable,ignore,mdbook-runnable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('fn double_first(vec: Vec<&str>) -> i32 {\n    let first = vec.first().unwrap(); // 生成错误 1\n    2 * first.parse::<i32>().unwrap() // 生成错误 2\n}\n\nfn main() {\n    let numbers = vec!["42", "93", "18"];\n    let empty = vec![];\n    let strings = vec!["tofu", "93", "18"];\n    \n    println!("The first doubled is {}", double_first(numbers));\n    \n    println!("The first doubled is {}", double_first(empty));\n    // 错误1：输入 vector 为空\n    \n    println!("The first doubled is {}", double_first(strings));\n    // 错误2：此元素不能解析成数字\n}\n')])])]),n("p",[e._v("在下面几节中，我们会看到处理这类问题的几种策略。")])])}),[],!1,null,null,null);t.default=s.exports}}]);