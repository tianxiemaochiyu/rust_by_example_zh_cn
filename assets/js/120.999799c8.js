(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{598:function(n,t,e){"use strict";e.r(t);var c=e(4),o=Object(c.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"super-和-self"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super-和-self"}},[n._v("#")]),n._v(" "),e("code",[n._v("super")]),n._v(" 和 "),e("code",[n._v("self")])]),n._v(" "),e("p",[n._v("可以在路径中使用 "),e("code",[n._v("super")]),n._v(" （父级）和 "),e("code",[n._v("self")]),n._v("（自身）关键字，从而在访问项时消除\n歧义，以及防止不必要的路径硬编码。")]),n._v(" "),e("div",{staticClass:"language-rust,editalbe extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('fn function() {\n    println!("called `function()`");\n}\n\nmod cool {\n    pub fn function() {\n        println!("called `cool::function()`");\n    }\n}\n\nmod my {\n    fn function() {\n        println!("called `my::function()`");\n    }\n    \n    mod cool {\n        pub fn function() {\n            println!("called `my::cool::function()`");\n        }\n    }\n    \n    pub fn indirect_call() {\n        // 让我们从这个作用域中访问所有名为 `function` 的函数！\n        print!("called `my::indirect_call()`, that\\n> ");\n        \n        // `self` 关键字表示当前的模块作用域——在这个例子是 `my`。\n        // 调用 `self::function()` 和直接调用 `function()` 都得到相同的结果，\n        // 因为他们表示相同的函数。\n        self::function();\n        function();\n        \n        // 我们也可以使用 `self` 来访问 `my` 内部的另一个模块：\n        self::cool::function();\n        \n        // `super` 关键字表示父作用域（在 `my` 模块外面）。\n        super::function();\n        \n        // 这将在 *crate* 作用域内绑定 `cool::function` 。\n        // 在这个例子中，crate 作用域是最外面的作用域。\n        {\n            use crate::cool::function as root_function;\n            root_function();\n        }\n    }\n}\n\nfn main() {\n    my::indirect_call();\n}\n')])])])])}),[],!1,null,null,null);t.default=o.exports}}]);