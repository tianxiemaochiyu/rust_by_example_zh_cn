(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{512:function(n,t,e){"use strict";e.r(t);var r=e(4),i=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"结构体"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构体"}},[n._v("#")]),n._v(" 结构体")]),n._v(" "),e("p",[n._v("结构体（structure，缩写成 struct）有 3 种类型，使用 "),e("code",[n._v("struct")]),n._v(" 关键字来创建：")]),n._v(" "),e("ul",[e("li",[n._v("元组结构体（tuple struct），事实上就是具名元组而已。")]),n._v(" "),e("li",[n._v("经典的 "),e("a",{attrs:{href:"http://en.wikipedia.org/wiki/Struct_(C_programming_language)",target:"_blank",rel:"noopener noreferrer"}},[n._v("C 语言风格结构体"),e("OutboundLink")],1),n._v("（C struct）。")]),n._v(" "),e("li",[n._v("单元结构体（unit struct），不带字段，在泛型中很有用。")])]),n._v(" "),e("div",{staticClass:"language-rust,editable extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#[derive(Debug)]\nstruct Person<\'a> {\n    name: &\'a str,\n    age: u8,\n}\n\n// 单元结构体\nstruct Nil;\n\n// 元组结构体\nstruct Pair(i32, f32);\n\n// 带有两个字段（field）的结构体\nstruct Point {\n    x: f32,\n    y: f32,\n}\n\n// 结构体可以作为另一个结构体的字段\n#[allow(dead_code)]\nstruct Rectangle {\n    p1: Point,\n    p2: Point,\n}\n\nfn main() {\n    // 使用简单的写法初始化字段，并创建结构体\n    let name = "Peter";\n    let age = 27;\n    let peter = Person { name, age };\n    \n    // 以 Debug 方式打印结构体\n    println!("{:?}", peter);\n    \n    // 实例化结构体 `Point`\n    let point: Point = Point { x: 0.3, y: 0.4 };\n\n    // 访问 point 的字段\n    println!("point coordinates: ({}, {})", point.x, point.y);\n    \n    // 使用结构体更新语法创建新的 point，这样可以用到之前的 point 的字段\n    let new_point = Point { x: 0.1, ..point };\n    \n    // `new_point.y` 与 `point.y` 一样，因为这个字段就是从 `point` 中来的\n    println!("second point: ({}, {})", new_point.x, new_point.y);\n    \n    // 使用 `let` 绑定来解构 point\n    let Point { x: my_x, y: my_y } = point;\n\n    let _rectangle = Rectangle {\n        // 结构体的实例化也是一个表达式\n        p1: Point { x: my_y, y: my_x },\n        p2: point,\n    };\n\n    // 实例化一个单元结构体\n    let _nil = Nil;\n\n    // 实例化一个元组结构体\n    let pair = Pair(1, 0.1);\n\n    // 访问元组结构体的字段\n    println!("pair contains {:?} and {:?}", pair.0, pair.1);\n\n    // 解构一个元组结构体\n    let Pair(integer, decimal) = pair;\n\n    println!("pair contains {:?} and {:?}", integer, decimal);\n}\n')])])]),e("h3",{attrs:{id:"动手试一试："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动手试一试："}},[n._v("#")]),n._v(" 动手试一试：")]),n._v(" "),e("ol",[e("li",[n._v("增加一个计算长方形面积的函数 "),e("code",[n._v("rect_area")]),n._v("（尝试使用嵌套的解构方式）。")]),n._v(" "),e("li",[n._v("增加一个函数 "),e("code",[n._v("square")]),n._v("，接受的参数是一个 "),e("code",[n._v("Point")]),n._v(" 和一个 "),e("code",[n._v("f32")]),n._v("，并返回一个\n"),e("code",[n._v("Rectangle")]),n._v("（长方形），其左下角的点等于 "),e("code",[n._v("Point")]),n._v(" 参数，长和宽都等于 "),e("code",[n._v("f32")]),n._v("\n参数。")])]),n._v(" "),e("h3",{attrs:{id:"参见："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参见："}},[n._v("#")]),n._v(" 参见：")]),n._v(" "),e("p",[e("RouterLink",{attrs:{to:"/attribute.html"}},[e("code",[n._v("attributes")])]),n._v(" 和 "),e("RouterLink",{attrs:{to:"/flow_control/match/destructuring.html"}},[n._v("解构")])],1)])}),[],!1,null,null,null);t.default=i.exports}}]);