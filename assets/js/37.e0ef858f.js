(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{515:function(e,n,_){"use strict";_.r(n);var t=_(4),v=Object(t.a)({},(function(){var e=this,n=e.$createElement,_=e._self._c||n;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"错误处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[e._v("#")]),e._v(" 错误处理")]),e._v(" "),_("p",[e._v("错误处理（error handling）是处理可能发生的失败情况的过程。例如读取一个文件时\n失败了，如果继续使用这个"),_("strong",[e._v("无效的")]),e._v("输入，那显然是有问题的。注意到并且显式地\n处理这种错误可以避免程序的其他部分产生潜在的问题。")]),e._v(" "),_("p",[e._v("在 Rust 中有多种处理错误的方式，在接下来的小节中会一一介绍。它们多少有些\n区别，使用场景也不尽相同。总的来说：")]),e._v(" "),_("ul",[_("li",[e._v("显式的 "),_("code",[e._v("panic")]),e._v(" 主要用于测试，以及处理不可恢复的错误。在原型开发中这很有用，比如\n用来测试还没有实现的函数，不过这时使用 "),_("code",[e._v("unimplemented")]),e._v(" 更能表达意图。另外在\n测试中，"),_("code",[e._v("panic")]),e._v(" 是一种显式地失败（fail）的好方法。")]),e._v(" "),_("li",[_("code",[e._v("Option")]),e._v(" 类型是为了值是可选的、或者缺少值并不是错误的情况准备的。比如说寻找\n父目录时，"),_("code",[e._v("/")]),e._v(" 和 "),_("code",[e._v("C:")]),e._v(" 这样的目录就没有父目录，这应当并不是一个错误。当处理\n"),_("code",[e._v("Option")]),e._v(" 时，"),_("code",[e._v("unwrap")]),e._v(" 可用于原型开发，也可以用于能够确定 "),_("code",[e._v("Option")]),e._v(" 中一定有值\n的情形。然而 "),_("code",[e._v("expect")]),e._v(" 更有用，因为它允许你指定一条错误信息，以免万一还是出现\n了错误。")]),e._v(" "),_("li",[e._v("当错误有可能发生，且应当由调用者处理时，使用 "),_("code",[e._v("Result")]),e._v("。你也可以 "),_("code",[e._v("unwrap")]),e._v(" 然后\n使用 "),_("code",[e._v("expect")]),e._v("，但是除了在测试或者原型开发中，请不要这样做。")])]),e._v(" "),_("p",[e._v("有关错误处理的更多内容，可参考"),_("a",{attrs:{href:"https://doc.rust-lang.org/book/error-handling.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),_("OutboundLink")],1),e._v("的错误处理的章节。")])])}),[],!1,null,null,null);n.default=v.exports}}]);