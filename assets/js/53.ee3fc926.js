(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{534:function(t,r,n){"use strict";n.r(r);var e=n(4),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,n=t._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"result-的-map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#result-的-map"}},[t._v("#")]),t._v(" "),n("code",[t._v("Result")]),t._v(" 的 "),n("code",[t._v("map")])]),t._v(" "),n("p",[t._v("上一节的 "),n("code",[t._v("multiply")]),t._v(" 函数的 panic 设计不是健壮的（robust）。一般地，我们希望把\n错误返回给调用者，这样它可以决定回应错误的正确方式。")]),t._v(" "),n("p",[t._v("首先，我们需要了解需要处理的错误类型是什么。为了确定 "),n("code",[t._v("Err")]),t._v(" 的类型，我们可以\n用 "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/primitive.str.html#method.parse",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("parse()")]),n("OutboundLink")],1),t._v(" 来试验。Rust 已经为 "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/primitive.i32.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("i32")]),n("OutboundLink")],1),t._v(" 类型使用\n"),n("a",{attrs:{href:"https://doc.rust-lang.org/std/str/trait.FromStr.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("FromStr")]),n("OutboundLink")],1),t._v(" trait 实现了 "),n("code",[t._v("parse()")]),t._v("。结果表明，这里的 "),n("code",[t._v("Err")]),t._v(" 类型被指定为\n"),n("a",{attrs:{href:"https://doc.rust-lang.org/std/num/struct.ParseIntError.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("ParseIntError")]),n("OutboundLink")],1),t._v("。")]),t._v(" "),n("blockquote",[n("p",[t._v("译注：原文没有具体讲如何确定 "),n("code",[t._v("Err")]),t._v(" 的类型。由于目前用于获取类型的函数仍然是不\n稳定的，我们可以用间接的方法。使用下面的代码：")]),t._v(" "),n("div",{staticClass:"language-rust,editable,ignore extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('fn main () {\n    let i: () = "t".parse::<i32>();\n}\n')])])]),n("p",[t._v("由于不可能把 "),n("code",[t._v("Result")]),t._v(" 类型赋给单元类型变量 "),n("code",[t._v("i")]),t._v("，编译器会提示我们：")]),t._v(" "),n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("note: expected type `()`\n         found type `std::result::Result<i32, std::num::ParseIntError>`\n")])])]),n("p",[t._v("这样就知道了 "),n("code",[t._v("parse<i32>")]),t._v(" 函数的返回类型详情。")])]),t._v(" "),n("p",[t._v("在下面的例子中，使用简单的 "),n("code",[t._v("match")]),t._v(" 语句导致了更加繁琐的代码。")]),t._v(" "),n("div",{staticClass:"language-rust,editable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('use std::num::ParseIntError;\n\n// 修改了上一节中的返回类型，现在使用模式匹配而不是 `unwrap()`。\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\n    match first_number_str.parse::<i32>() {\n        Ok(first_number)  => {\n            match second_number_str.parse::<i32>() {\n                Ok(second_number)  => {\n                    Ok(first_number * second_number)\n                },\n                Err(e) => Err(e),\n            }\n        },\n        Err(e) => Err(e),\n    }\n}\n\nfn print(result: Result<i32, ParseIntError>) {\n    match result {\n        Ok(n)  => println!("n is {}", n),\n        Err(e) => println!("Error: {}", e),\n    }\n}\n\nfn main() {\n    // 这种情形下仍然会给出正确的答案。\n    let twenty = multiply("10", "2");\n    print(twenty);\n\n    // 这种情况下就会提供一条更有用的错误信息。\n    let tt = multiply("t", "2");\n    print(tt);\n}\n')])])]),n("p",[t._v("幸运的是，"),n("code",[t._v("Option")]),t._v(" 的 "),n("code",[t._v("map")]),t._v("、"),n("code",[t._v("and_then")]),t._v("、以及很多其他组合算子也为 "),n("code",[t._v("Result")]),t._v(" 实现\n了。官方文档的 "),n("a",{attrs:{href:"https://doc.rust-lang.org/std/result/enum.Result.html",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("Result")]),n("OutboundLink")],1),t._v(" 一节包含完整的方法列表。")]),t._v(" "),n("div",{staticClass:"language-rust,editable extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('use std::num::ParseIntError;\n\n// 就像 `Option` 那样，我们可以使用 `map()` 之类的组合算子。\n// 除去写法外，这个函数与上面那个完全一致，它的作用是：\n// 如果值是合法的，计算其乘积，否则返回错误。\nfn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {\n    first_number_str.parse::<i32>().and_then(|first_number| {\n        second_number_str.parse::<i32>().map(|second_number| first_number * second_number)\n    })\n}\n\nfn print(result: Result<i32, ParseIntError>) {\n    match result {\n        Ok(n)  => println!("n is {}", n),\n        Err(e) => println!("Error: {}", e),\n    }\n}\n\nfn main() {\n    // 这种情况下仍然会给出正确的答案。\n    let twenty = multiply("10", "2");\n    print(twenty);\n\n    // 这种情况下就会提供一条更有用的错误信息。\n    let tt = multiply("t", "2");\n    print(tt);\n}\n')])])])])}),[],!1,null,null,null);r.default=s.exports}}]);